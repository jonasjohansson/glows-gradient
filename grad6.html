<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>Glows Gradient</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0f0f0f;
      }
      .stage {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        overflow: hidden;
        background-image: url("cozy - 1291.jpg");
        background-size: cover;
        background-position: center top;
        background-repeat: no-repeat;
      }
      svg {
        width: min(90vw, 1200px);
        height: auto;
        display: block;
        overflow: visible;
      }

      #shapesGroup {
        filter: blur(0px);
        transition: filter 0.3s ease;
      }

      use[href="#shapePath"] {
        transform-origin: center;
        transform-box: fill-box;
      }
    </style>
  </head>
  <body>
    <div class="stage">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 1885.76 1161.29">
        <defs>
          <path
            id="shapePath"
            d="M104,707.88c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,516.68,182.89,738.46,119.23,203.13-58.31,162.62-132.51,469.23-250,177.18-67.9,293.4-82.47,334.62-180.77,29.04-69.26,3.49-138.71-34.62-242.31-28.72-78.07-89.01-235.1-253.85-346.15C1534.34,70.06,1424.01-4.27,1273.23.19c-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-83.49,117.93-165.38,165.38-95.29,55.22-228.68,73.34-346.15,34.62-154.72-51-194.53-171.81-276.92-150-62.17,16.46-90.97,98.86-111.54,157.69-9.08,25.97-47.39,135.58,0,242.31,22.51,50.7,54.66,78.89,80.77,103.85Z" />
          <path
            id="shapePath2"
            d="M80.94,728.19c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,528.22,713.66,750,650,203.13-58.31,151.08-663.28,457.69-780.77,177.18-67.9-210.44,2.15-169.23-96.15,29.04-69.26,507.34-223.32,469.23-326.92-28.72-78.07-89.01-235.1-253.85-346.15-50.43-33.97-160.76-108.31-311.54-103.85-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-287.34-216.68-369.23-169.23-95.29,55.22-24.83,407.95-142.31,369.23-154.72-51,93.94,139.72,11.54,161.54C338.01,552.34,20.74,323.2.18,382.04c-9.08,25.97,337.22,339.42,384.62,446.15,22.51,50.7-329.96-124.96-303.85-100Z" />

          <!-- Create gradient filter for shape 1 -->
          <filter
            id="shapeGradient1"
            filterUnits="userSpaceOnUse"
            x="-600"
            y="-600"
            width="3000"
            height="2400">
            <!-- Organic displacement using turbulence -->
            <feTurbulence
              id="displaceTurbulence"
              type="fractalNoise"
              baseFrequency="0.01 0.01"
              numOctaves="5"
              result="turbulence"
              seed="1" />
            <feDisplacementMap
              id="displaceMap"
              in="SourceGraphic"
              in2="turbulence"
              scale="0"
              xChannelSelector="R"
              yChannelSelector="G"
              result="displaced" />

            <!-- Extract alpha from displaced shape -->
            <feColorMatrix
              in="displaced"
              type="matrix"
              values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0"
              result="displacedAlpha" />

            <!-- Blur SourceAlpha to create distance field: center is bright (1), edges fade to dark (0) -->
            <feGaussianBlur
              in="displacedAlpha"
              stdDeviation="200"
              result="blurred"
              id="dfBlur" />
            <!-- Invert so center = 0 (maps to red) and edge = 1 (maps to magenta) -->
            <feComponentTransfer
              in="blurred"
              result="inverted">
              <feFuncA
                type="table"
                tableValues="1 0" />
            </feComponentTransfer>
            <!-- Copy alpha channel to RGB so we can map colors based on intensity -->
            <feColorMatrix
              in="inverted"
              type="matrix"
              values="0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 0"
              result="grayRGB" />

            <!-- Rainbow mapping from center → edges using table-based RGB lookups -->
            <!-- Order (center to edge): red → orange → yellow → green → cyan → blue → magenta
                 The alpha fades outward so it dissolves into the background. -->
            <feComponentTransfer
              in="grayRGB"
              result="gradient">
              <!-- R:  red(1) → orange(1) → yellow(1) → green(0) → cyan(0) → blue(0) → magenta(1) -->
              <feFuncR
                type="table"
                tableValues="1 1 1 0 0 0 1"
                id="funcR1" />
              <!-- G:  red(0) → orange(0.5) → yellow(1) → green(1) → cyan(1) → blue(0) → magenta(0) -->
              <feFuncG
                type="table"
                tableValues="0 0.5 1 1 1 0 0"
                id="funcG1" />
              <!-- B:  red(0) → orange(0) → yellow(0) → green(0) → cyan(1) → blue(1) → magenta(1) -->
              <feFuncB
                type="table"
                tableValues="0 0 0 0 1 1 1"
                id="funcB1" />
              <!-- Alpha: keep bright in center, fade gradually to edge -->
              <feFuncA
                type="table"
                tableValues="1.0 1.0 0.95 0.85 0.7 0.4 0.0"
                id="funcA1" />
            </feComponentTransfer>

            <!-- Extra feather: blur the displaced alpha and use as a soft edge mask -->
            <feGaussianBlur
              id="featherBlur"
              in="displacedAlpha"
              stdDeviation="40"
              result="featherMask" />
            <feComposite
              in="gradient"
              in2="featherMask"
              operator="in"
              result="feathered" />

            <!-- Brightness and Contrast adjustments -->
            <feComponentTransfer
              in="feathered"
              result="final">
              <feFuncR
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessR1" />
              <feFuncG
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessG1" />
              <feFuncB
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessB1" />
            </feComponentTransfer>
          </filter>

          <!-- Create gradient filter for shape 2 (duplicate of shape 1) -->
          <filter
            id="shapeGradient2"
            filterUnits="userSpaceOnUse"
            x="-600"
            y="-600"
            width="3000"
            height="2400">
            <!-- Organic displacement using turbulence -->
            <feTurbulence
              id="displaceTurbulence2"
              type="fractalNoise"
              baseFrequency="0.01 0.01"
              numOctaves="5"
              result="turbulence2"
              seed="1" />
            <feDisplacementMap
              id="displaceMap2"
              in="SourceGraphic"
              in2="turbulence2"
              scale="0"
              xChannelSelector="R"
              yChannelSelector="G"
              result="displaced2" />

            <!-- Extract alpha from displaced shape -->
            <feColorMatrix
              in="displaced2"
              type="matrix"
              values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0"
              result="displacedAlpha2" />

            <!-- Blur SourceAlpha to create distance field: center is bright (1), edges fade to dark (0) -->
            <feGaussianBlur
              in="displacedAlpha2"
              stdDeviation="200"
              result="blurred2"
              id="dfBlur2" />
            <!-- Invert so center = 0 (maps to red) and edge = 1 (maps to magenta) -->
            <feComponentTransfer
              in="blurred2"
              result="inverted2">
              <feFuncA
                type="table"
                tableValues="1 0" />
            </feComponentTransfer>
            <!-- Copy alpha channel to RGB so we can map colors based on intensity -->
            <feColorMatrix
              in="inverted2"
              type="matrix"
              values="0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 0"
              result="grayRGB2" />

            <!-- Rainbow mapping from center → edges using table-based RGB lookups -->
            <feComponentTransfer
              in="grayRGB2"
              result="gradient2">
              <!-- R:  red(1) → orange(1) → yellow(1) → green(0) → cyan(0) → blue(0) → magenta(1) -->
              <feFuncR
                type="table"
                tableValues="1 1 1 0 0 0 1"
                id="funcR2" />
              <!-- G:  red(0) → orange(0.5) → yellow(1) → green(1) → cyan(1) → blue(0) → magenta(0) -->
              <feFuncG
                type="table"
                tableValues="0 0.5 1 1 1 0 0"
                id="funcG2" />
              <!-- B:  red(0) → orange(0) → yellow(0) → green(0) → cyan(1) → blue(1) → magenta(1) -->
              <feFuncB
                type="table"
                tableValues="0 0 0 0 1 1 1"
                id="funcB2" />
              <!-- Alpha: keep bright in center, fade gradually to edge -->
              <feFuncA
                type="table"
                tableValues="1.0 1.0 0.95 0.85 0.7 0.4 0.0"
                id="funcA2" />
            </feComponentTransfer>

            <!-- Extra feather: blur the displaced alpha and use as a soft edge mask -->
            <feGaussianBlur
              id="featherBlur2"
              in="displacedAlpha2"
              stdDeviation="40"
              result="featherMask2" />
            <feComposite
              in="gradient2"
              in2="featherMask2"
              operator="in"
              result="feathered2" />

            <!-- Brightness and Contrast adjustments -->
            <feComponentTransfer
              in="feathered2"
              result="final2">
              <feFuncR
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessR2" />
              <feFuncG
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessG2" />
              <feFuncB
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessB2" />
            </feComponentTransfer>
          </filter>
        </defs>

        <!-- Apply gradient filter -->
        <g id="shapesGroup">
          <use
            id="shapeUse"
            href="#shapePath"
            fill="white"
            filter="url(#shapeGradient1)" />
          <use
            id="shapeUse2"
            href="#shapePath2"
            fill="white"
            filter="url(#shapeGradient2)" />
        </g>
      </svg>
      <!-- lil-gui -->
      <script type="module">
        import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.21/+esm";
        const gui = new GUI();
        const params = {
          // Five color stops from center→edge - Shape 1
          stop1_1: "#FFD700", // Bright golden yellow
          stop2_1: "#FF7F00", // Rich orange
          stop3_1: "#E91E63", // Warm magenta
          stop4_1: "#9C27B0", // Purple
          stop5_1: "#483D8B", // Deep indigo
          // Color stop positions (0-1, center to edge) - Shape 1
          stopPos1_1: 0.0,
          stopPos2_1: 0.2,
          stopPos3_1: 0.5,
          stopPos4_1: 0.8,
          stopPos5_1: 1.0,
          // Five color stops from center→edge - Shape 2
          stop1_2: "#FFD700", // Bright golden yellow
          stop2_2: "#FF7F00", // Rich orange
          stop3_2: "#E91E63", // Warm magenta
          stop4_2: "#9C27B0", // Purple
          stop5_2: "#483D8B", // Deep indigo
          // Color stop positions (0-1, center to edge) - Shape 2
          stopPos1_2: 0.0,
          stopPos2_2: 0.2,
          stopPos3_2: 0.5,
          stopPos4_2: 0.8,
          stopPos5_2: 1.0,
          blur: 200,
          centerOpacity1: 1.0,
          edgeOpacity1: 0.0,
          centerOpacity2: 1.0,
          edgeOpacity2: 0.0,
          // Transform controls - Shape 1
          positionX1: 0,
          positionY1: 0,
          scale1: 1.0,
          rotation1: 0,
          skewX1: 0,
          skewY1: 0,
          // Transform controls - Shape 2
          positionX2: 0,
          positionY2: 0,
          scale2: 1.0,
          rotation2: 0,
          skewX2: 0,
          skewY2: 0,
          // Blob effect
          blobBlur: 0,
          // Feather control
          feather: 40,
          // Visual effects
          brightness: 1.0,
          contrast: 1.0,
          // Displacement controls
          displacementStrength: 0,
          displacementFrequency: 0.01,
          displacementOctaves: 5,
          displacementAnimated: false,
          displacementSpeed: 0.005,
          // Path data (stored as initial value)
          pathData:
            "M104,707.88c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,516.68,182.89,738.46,119.23,203.13-58.31,162.62-132.51,469.23-250,177.18-67.9,293.4-82.47,334.62-180.77,29.04-69.26,3.49-138.71-34.62-242.31-28.72-78.07-89.01-235.1-253.85-346.15C1534.34,70.06,1424.01-4.27,1273.23.19c-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-83.49,117.93-165.38,165.38-95.29,55.22-228.68,73.34-346.15,34.62-154.72-51-194.53-171.81-276.92-150-62.17,16.46-90.97,98.86-111.54,157.69-9.08,25.97-47.39,135.58,0,242.31,22.51,50.7,54.66,78.89,80.77,103.85Z",
          pathData2:
            "M80.94,728.19c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,528.22,713.66,750,650,203.13-58.31,151.08-663.28,457.69-780.77,177.18-67.9-210.44,2.15-169.23-96.15,29.04-69.26,507.34-223.32,469.23-326.92-28.72-78.07-89.01-235.1-253.85-346.15-50.43-33.97-160.76-108.31-311.54-103.85-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-287.34-216.68-369.23-169.23-95.29,55.22-24.83,407.95-142.31,369.23-154.72-51,93.94,139.72,11.54,161.54C338.01,552.34,20.74,323.2.18,382.04c-9.08,25.97,337.22,339.42,384.62,446.15,22.51,50.7-329.96-124.96-303.85-100Z",
        };

        const toRGB01 = (hex) => {
          const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex);
          if (!m) return [1, 1, 1];
          return [parseInt(m[1], 16) / 255, parseInt(m[2], 16) / 255, parseInt(m[3], 16) / 255];
        };

        function interpolateColorStops(colors, positions) {
          // Create an array of 256 entries (0-255) representing the gradient
          const result = new Array(256);
          const numStops = colors.length;

          for (let i = 0; i < 256; i++) {
            const t = i / 255; // Normalize to 0-1

            // Find which two stops to interpolate between
            let stopIndex = 0;
            for (let j = 0; j < numStops - 1; j++) {
              if (t >= positions[j] && t <= positions[j + 1]) {
                stopIndex = j;
                break;
              }
            }

            // Clamp to last stop if beyond
            if (t > positions[numStops - 1]) {
              stopIndex = numStops - 2;
            }

            const pos1 = positions[stopIndex];
            const pos2 = positions[stopIndex + 1];
            const color1 = colors[stopIndex];
            const color2 = colors[stopIndex + 1];

            // Interpolate between the two stops
            const range = pos2 - pos1;
            const localT = range > 0 ? (t - pos1) / range : 0;

            result[i] = [
              color1[0] + (color2[0] - color1[0]) * localT,
              color1[1] + (color2[1] - color1[1]) * localT,
              color1[2] + (color2[2] - color1[2]) * localT,
            ];
          }

          // Sample 7 points evenly to create table values
          const samplePoints = [0, 42, 85, 128, 170, 213, 255];
          return samplePoints.map((idx) => result[idx]);
        }

        function updateTables1() {
          const colors = [params.stop1_1, params.stop2_1, params.stop3_1, params.stop4_1, params.stop5_1].map(toRGB01);
          const positions = [params.stopPos1_1, params.stopPos2_1, params.stopPos3_1, params.stopPos4_1, params.stopPos5_1]
            .map((p) => Math.max(0, Math.min(1, p)))
            .sort((a, b) => a - b);

          // Ensure positions are sorted and clamp colors accordingly
          const sortedPairs = positions.map((p, i) => ({ pos: p, color: colors[i] })).sort((a, b) => a.pos - b.pos);
          const sortedColors = sortedPairs.map((p) => p.color);
          const sortedPositions = sortedPairs.map((p) => p.pos);

          // Interpolate to create smooth gradient
          const interpolated = interpolateColorStops(sortedColors, sortedPositions);

          const r = interpolated.map((c) => c[0].toFixed(3)).join(" ");
          const g = interpolated.map((c) => c[1].toFixed(3)).join(" ");
          const b = interpolated.map((c) => c[2].toFixed(3)).join(" ");

          document.getElementById("funcR1")?.setAttribute("tableValues", r);
          document.getElementById("funcG1")?.setAttribute("tableValues", g);
          document.getElementById("funcB1")?.setAttribute("tableValues", b);

          // Interpolate alpha based on stop positions
          const alphaStops = [params.centerOpacity1, 0.95, 0.8, 0.55, params.edgeOpacity1];
          const alphaInterpolated = interpolateColorStops(
            alphaStops.map((a) => [a, a, a]),
            sortedPositions
          );
          const a = alphaInterpolated.map((c) => Math.max(0, Math.min(1, c[0])).toFixed(2)).join(" ");
          document.getElementById("funcA1")?.setAttribute("tableValues", a);
        }

        function updateTables2() {
          const colors = [params.stop1_2, params.stop2_2, params.stop3_2, params.stop4_2, params.stop5_2].map(toRGB01);
          const positions = [params.stopPos1_2, params.stopPos2_2, params.stopPos3_2, params.stopPos4_2, params.stopPos5_2]
            .map((p) => Math.max(0, Math.min(1, p)))
            .sort((a, b) => a - b);

          // Ensure positions are sorted and clamp colors accordingly
          const sortedPairs = positions.map((p, i) => ({ pos: p, color: colors[i] })).sort((a, b) => a.pos - b.pos);
          const sortedColors = sortedPairs.map((p) => p.color);
          const sortedPositions = sortedPairs.map((p) => p.pos);

          // Interpolate to create smooth gradient
          const interpolated = interpolateColorStops(sortedColors, sortedPositions);

          const r = interpolated.map((c) => c[0].toFixed(3)).join(" ");
          const g = interpolated.map((c) => c[1].toFixed(3)).join(" ");
          const b = interpolated.map((c) => c[2].toFixed(3)).join(" ");

          document.getElementById("funcR2")?.setAttribute("tableValues", r);
          document.getElementById("funcG2")?.setAttribute("tableValues", g);
          document.getElementById("funcB2")?.setAttribute("tableValues", b);

          // Interpolate alpha based on stop positions
          const alphaStops = [params.centerOpacity2, 0.95, 0.8, 0.55, params.edgeOpacity2];
          const alphaInterpolated = interpolateColorStops(
            alphaStops.map((a) => [a, a, a]),
            sortedPositions
          );
          const a = alphaInterpolated.map((c) => Math.max(0, Math.min(1, c[0])).toFixed(2)).join(" ");
          document.getElementById("funcA2")?.setAttribute("tableValues", a);
        }

        function updateBlur() {
          document.getElementById("dfBlur")?.setAttribute("stdDeviation", String(params.blur));
          document.getElementById("dfBlur2")?.setAttribute("stdDeviation", String(params.blur));
        }

        function updateTransform1() {
          const useEl = document.getElementById("shapeUse");
          if (!useEl) return;
          const tx = params.positionX1;
          const ty = params.positionY1;
          const s = params.scale1;
          const r = params.rotation1;
          const skx = params.skewX1;
          const sky = params.skewY1;
          // Build transform string: translate → skew → rotate → scale
          const transform = `translate(${tx}, ${ty}) skewX(${skx}) skewY(${sky}) rotate(${r}) scale(${s})`;
          useEl.setAttribute("transform", transform);
        }

        function updateTransform2() {
          const useEl2 = document.getElementById("shapeUse2");
          if (!useEl2) return;
          const tx = params.positionX2;
          const ty = params.positionY2;
          const s = params.scale2;
          const r = params.rotation2;
          const skx = params.skewX2;
          const sky = params.skewY2;
          // Build transform string: translate → skew → rotate → scale
          const transform = `translate(${tx}, ${ty}) skewX(${skx}) skewY(${sky}) rotate(${r}) scale(${s})`;
          useEl2.setAttribute("transform", transform);
        }

        function updateBlobBlur() {
          const shapesGroup = document.getElementById("shapesGroup");
          if (shapesGroup) {
            shapesGroup.style.filter = params.blobBlur > 0 ? `blur(${params.blobBlur}px)` : "none";
          }
        }

        function updateFeather() {
          document.getElementById("featherBlur")?.setAttribute("stdDeviation", String(params.feather));
          document.getElementById("featherBlur2")?.setAttribute("stdDeviation", String(params.feather));
        }

        function updateEffects() {
          // Brightness: linear slope = brightness value
          // Contrast: use slope = contrast, intercept = -0.5 * contrast + 0.5
          const brightness = params.brightness;
          const contrast = params.contrast;
          const slope = brightness * contrast;
          const intercept = brightness * (-0.5 * contrast + 0.5);

          // Apply to both shapes (shared brightness/contrast for now)
          document.getElementById("brightnessR1")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessR1")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessG1")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessG1")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessB1")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessB1")?.setAttribute("intercept", String(intercept));

          document.getElementById("brightnessR2")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessR2")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessG2")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessG2")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessB2")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessB2")?.setAttribute("intercept", String(intercept));
        }

        let displacementAnimationId = null;

        let displacementTime = 0;

        function updateDisplacement() {
          // Update both displacement maps
          document.getElementById("displaceMap")?.setAttribute("scale", String(params.displacementStrength));
          document.getElementById("displaceMap2")?.setAttribute("scale", String(params.displacementStrength));

          const freq = params.displacementFrequency;
          document.getElementById("displaceTurbulence")?.setAttribute("baseFrequency", `${freq} ${freq}`);
          document.getElementById("displaceTurbulence")?.setAttribute("numOctaves", String(params.displacementOctaves));
          document.getElementById("displaceTurbulence2")?.setAttribute("baseFrequency", `${freq} ${freq}`);
          document.getElementById("displaceTurbulence2")?.setAttribute("numOctaves", String(params.displacementOctaves));

          // Stop existing animation
          if (displacementAnimationId) {
            cancelAnimationFrame(displacementAnimationId);
            displacementAnimationId = null;
          }

          // Start animated displacement if enabled - lava lamp style
          if (params.displacementAnimated && params.displacementStrength > 0) {
            function animate() {
              displacementTime += params.displacementSpeed || 0.005;
              const baseFreq = params.displacementFrequency;
              const turbEl = document.getElementById("displaceTurbulence");
              const turbEl2 = document.getElementById("displaceTurbulence2");
              if (turbEl && turbEl2) {
                // Lava lamp style: slow, smooth, flowing movement
                // Multiple sine waves at different frequencies for organic flow
                const wave1 = Math.sin(displacementTime * 0.3) * 0.003;
                const wave2 = Math.cos(displacementTime * 0.5) * 0.005;
                const wave3 = Math.sin(displacementTime * 0.7 + 1.5) * 0.002;

                const x = baseFreq + wave1 + wave2;
                const y = baseFreq + wave3 + Math.cos(displacementTime * 0.4) * 0.004;
                turbEl.setAttribute("baseFrequency", `${x} ${y}`);
                // Shape 2 with slight phase offset for variation
                const x2 = baseFreq + Math.sin(displacementTime * 0.3 + 1.0) * 0.003;
                const y2 = baseFreq + Math.cos(displacementTime * 0.5 + 0.5) * 0.005;
                turbEl2.setAttribute("baseFrequency", `${x2} ${y2}`);
              }
              displacementAnimationId = requestAnimationFrame(animate);
            }
            animate();
          } else {
            // Reset when not animated
            displacementTime = 0;
          }
        }

        function updatePath() {
          const pathEl = document.getElementById("shapePath");
          if (pathEl && params.pathData.trim()) {
            try {
              pathEl.setAttribute("d", params.pathData);
            } catch (e) {
              console.error("Invalid path data:", e);
              alert("Invalid SVG path data. Please check the syntax.");
            }
          }
        }

        function updatePath2() {
          const pathEl = document.getElementById("shapePath2");
          if (pathEl && params.pathData2.trim()) {
            try {
              pathEl.setAttribute("d", params.pathData2);
            } catch (e) {
              console.error("Invalid path data:", e);
              alert("Invalid SVG path data. Please check the syntax.");
            }
          }
        }

        const cf1 = gui.addFolder("Shape 1 Colors (center → edge)");
        cf1.addColor(params, "stop1_1").name("Stop 1").onChange(updateTables1);
        cf1.addColor(params, "stop2_1").name("Stop 2").onChange(updateTables1);
        cf1.addColor(params, "stop3_1").name("Stop 3").onChange(updateTables1);
        cf1.addColor(params, "stop4_1").name("Stop 4").onChange(updateTables1);
        cf1.addColor(params, "stop5_1").name("Stop 5").onChange(updateTables1);
        const sp1 = gui.addFolder("Shape 1 Stop Positions");
        sp1.add(params, "stopPos1_1", 0, 1, 0.01).name("Stop 1 Position").onChange(updateTables1);
        sp1.add(params, "stopPos2_1", 0, 1, 0.01).name("Stop 2 Position").onChange(updateTables1);
        sp1.add(params, "stopPos3_1", 0, 1, 0.01).name("Stop 3 Position").onChange(updateTables1);
        sp1.add(params, "stopPos4_1", 0, 1, 0.01).name("Stop 4 Position").onChange(updateTables1);
        sp1.add(params, "stopPos5_1", 0, 1, 0.01).name("Stop 5 Position").onChange(updateTables1);
        const af1 = gui.addFolder("Shape 1 Alpha");
        af1.add(params, "centerOpacity1", 0, 1, 0.01).name("Center Opacity").onChange(updateTables1);
        af1.add(params, "edgeOpacity1", 0, 1, 0.01).name("Edge Opacity").onChange(updateTables1);

        const cf2 = gui.addFolder("Shape 2 Colors (center → edge)");
        cf2.addColor(params, "stop1_2").name("Stop 1").onChange(updateTables2);
        cf2.addColor(params, "stop2_2").name("Stop 2").onChange(updateTables2);
        cf2.addColor(params, "stop3_2").name("Stop 3").onChange(updateTables2);
        cf2.addColor(params, "stop4_2").name("Stop 4").onChange(updateTables2);
        cf2.addColor(params, "stop5_2").name("Stop 5").onChange(updateTables2);
        const sp2 = gui.addFolder("Shape 2 Stop Positions");
        sp2.add(params, "stopPos1_2", 0, 1, 0.01).name("Stop 1 Position").onChange(updateTables2);
        sp2.add(params, "stopPos2_2", 0, 1, 0.01).name("Stop 2 Position").onChange(updateTables2);
        sp2.add(params, "stopPos3_2", 0, 1, 0.01).name("Stop 3 Position").onChange(updateTables2);
        sp2.add(params, "stopPos4_2", 0, 1, 0.01).name("Stop 4 Position").onChange(updateTables2);
        sp2.add(params, "stopPos5_2", 0, 1, 0.01).name("Stop 5 Position").onChange(updateTables2);
        const af2 = gui.addFolder("Shape 2 Alpha");
        af2.add(params, "centerOpacity2", 0, 1, 0.01).name("Center Opacity").onChange(updateTables2);
        af2.add(params, "edgeOpacity2", 0, 1, 0.01).name("Edge Opacity").onChange(updateTables2);

        gui.add(params, "blur", 50, 400, 1).name("Blur (spread)").onChange(updateBlur);

        const tf1 = gui.addFolder("Shape 1 Transform");
        tf1.add(params, "positionX1", -2000, 2000, 1).name("Position X").onChange(updateTransform1);
        tf1.add(params, "positionY1", -2000, 2000, 1).name("Position Y").onChange(updateTransform1);
        tf1.add(params, "scale1", 0.1, 3, 0.01).name("Scale").onChange(updateTransform1);
        tf1.add(params, "rotation1", -180, 180, 1).name("Rotation (deg)").onChange(updateTransform1);
        tf1.add(params, "skewX1", -45, 45, 0.5).name("Skew X (deg)").onChange(updateTransform1);
        tf1.add(params, "skewY1", -45, 45, 0.5).name("Skew Y (deg)").onChange(updateTransform1);

        const tf2 = gui.addFolder("Shape 2 Transform");
        tf2.add(params, "positionX2", -2000, 2000, 1).name("Position X").onChange(updateTransform2);
        tf2.add(params, "positionY2", -2000, 2000, 1).name("Position Y").onChange(updateTransform2);
        tf2.add(params, "scale2", 0.1, 3, 0.01).name("Scale").onChange(updateTransform2);
        tf2.add(params, "rotation2", -180, 180, 1).name("Rotation (deg)").onChange(updateTransform2);
        tf2.add(params, "skewX2", -45, 45, 0.5).name("Skew X (deg)").onChange(updateTransform2);
        tf2.add(params, "skewY2", -45, 45, 0.5).name("Skew Y (deg)").onChange(updateTransform2);

        const bf = gui.addFolder("Blob Effect");
        bf.add(params, "blobBlur", 0, 200, 1).name("Blob Blur").onChange(updateBlobBlur);

        const ff = gui.addFolder("Edge Feather");
        ff.add(params, "feather", 0, 150, 1).name("Feather Amount").onChange(updateFeather);

        const vf = gui.addFolder("Visual Effects");
        vf.add(params, "brightness", 0, 3, 0.01).name("Brightness").onChange(updateEffects);
        vf.add(params, "contrast", 0, 3, 0.01).name("Contrast").onChange(updateEffects);

        const df = gui.addFolder("Displacement");
        df.add(params, "displacementStrength", 0, 1000, 5).name("Strength").onChange(updateDisplacement);
        df.add(params, "displacementFrequency", 0.005, 0.05, 0.001).name("Frequency (lower = smoother)").onChange(updateDisplacement);
        df.add(params, "displacementOctaves", 1, 8, 1).name("Octaves").onChange(updateDisplacement);
        df.add(params, "displacementAnimated").name("Lava Lamp (animated)").onChange(updateDisplacement);
        df.add(params, "displacementSpeed", 0.001, 0.02, 0.001).name("Animation Speed").onChange(updateDisplacement);

        const pathf = gui.addFolder("Shape Path");
        const pathController = pathf.add(params, "pathData").name("Shape 1 Path").onChange(updatePath);
        pathf.add({ update: () => updatePath() }, "update").name("Update Shape 1");
        const pathController2 = pathf.add(params, "pathData2").name("Shape 2 Path").onChange(updatePath2);
        pathf.add({ update: () => updatePath2() }, "update").name("Update Shape 2");

        // Store initial paths on load
        params.pathData = document.getElementById("shapePath")?.getAttribute("d") || params.pathData;
        params.pathData2 = document.getElementById("shapePath2")?.getAttribute("d") || params.pathData2;

        // Position GUI on the left
        setTimeout(() => {
          gui.domElement.style.position = "fixed";
          gui.domElement.style.top = "20px";
          gui.domElement.style.left = "20px";
          gui.domElement.style.zIndex = "1000";
        }, 100);

        updateTables1();
        updateTables2();
        updateBlur();
        updateTransform1();
        updateTransform2();
        updateFeather();
        updateEffects();
        updateDisplacement();
        updatePath2();
        updateBlobBlur();
      </script>
    </div>
  </body>
</html>
