<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>Glows Gradient</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0f0f0f;
      }
      .stage {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        overflow: hidden;
        background-image: url("cozy - 1291.jpg");
        background-size: cover;
        background-position: center top;
        background-repeat: no-repeat;
      }
      svg {
        width: min(90vw, 1200px);
        height: auto;
        display: block;
        overflow: visible;
      }

      use[href="#shapePath"] {
        transform-origin: center;
        transform-box: fill-box;
      }
    </style>
  </head>
  <body>
    <div class="stage">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 1885.76 1161.29">
        <defs>
          <path
            id="shapePath"
            d="M104,707.88c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,516.68,182.89,738.46,119.23,203.13-58.31,162.62-132.51,469.23-250,177.18-67.9,293.4-82.47,334.62-180.77,29.04-69.26,3.49-138.71-34.62-242.31-28.72-78.07-89.01-235.1-253.85-346.15C1534.34,70.06,1424.01-4.27,1273.23.19c-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-83.49,117.93-165.38,165.38-95.29,55.22-228.68,73.34-346.15,34.62-154.72-51-194.53-171.81-276.92-150-62.17,16.46-90.97,98.86-111.54,157.69-9.08,25.97-47.39,135.58,0,242.31,22.51,50.7,54.66,78.89,80.77,103.85Z" />

          <!-- Create gradient that follows shape using blur-based distance field -->
          <filter
            id="shapeGradient"
            filterUnits="userSpaceOnUse"
            x="-600"
            y="-600"
            width="3000"
            height="2400">
            <!-- Blur SourceAlpha to create distance field: center is bright (1), edges fade to dark (0) -->
            <feGaussianBlur
              in="SourceAlpha"
              stdDeviation="200"
              result="blurred"
              id="dfBlur" />
            <!-- Invert so center = 0 (maps to red) and edge = 1 (maps to magenta) -->
            <feComponentTransfer
              in="blurred"
              result="inverted">
              <feFuncA
                type="table"
                tableValues="1 0" />
            </feComponentTransfer>
            <!-- Copy alpha channel to RGB so we can map colors based on intensity -->
            <feColorMatrix
              in="inverted"
              type="matrix"
              values="0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 0"
              result="grayRGB" />

            <!-- Rainbow mapping from center → edges using table-based RGB lookups -->
            <!-- Order (center to edge): red → orange → yellow → green → cyan → blue → magenta
                 The alpha fades outward so it dissolves into the background. -->
            <feComponentTransfer
              in="grayRGB"
              result="gradient">
              <!-- R:  red(1) → orange(1) → yellow(1) → green(0) → cyan(0) → blue(0) → magenta(1) -->
              <feFuncR
                type="table"
                tableValues="1 1 1 0 0 0 1"
                id="funcR" />
              <!-- G:  red(0) → orange(0.5) → yellow(1) → green(1) → cyan(1) → blue(0) → magenta(0) -->
              <feFuncG
                type="table"
                tableValues="0 0.5 1 1 1 0 0"
                id="funcG" />
              <!-- B:  red(0) → orange(0) → yellow(0) → green(0) → cyan(1) → blue(1) → magenta(1) -->
              <feFuncB
                type="table"
                tableValues="0 0 0 0 1 1 1"
                id="funcB" />
              <!-- Alpha: keep bright in center, fade gradually to edge -->
              <feFuncA
                type="table"
                tableValues="1.0 1.0 0.95 0.85 0.7 0.4 0.0"
                id="funcA" />
            </feComponentTransfer>

            <!-- Extra feather: blur the original alpha and use as a soft edge mask -->
            <feGaussianBlur
              id="featherBlur"
              in="SourceAlpha"
              stdDeviation="40"
              result="featherMask" />
            <feComposite
              in="gradient"
              in2="featherMask"
              operator="in"
              result="feathered" />

            <!-- Brightness and Contrast adjustments -->
            <feComponentTransfer
              in="feathered"
              result="final">
              <feFuncR
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessR" />
              <feFuncG
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessG" />
              <feFuncB
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessB" />
            </feComponentTransfer>
          </filter>
        </defs>

        <!-- Apply gradient filter -->
        <use
          id="shapeUse"
          href="#shapePath"
          fill="white"
          filter="url(#shapeGradient)" />
      </svg>
      <!-- lil-gui -->
      <script type="module">
        import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.21/+esm";
        const gui = new GUI();
        const params = {
          // Five color stops from center→edge - matching warm to cool gradient
          stop1: "#FFD700", // Bright golden yellow
          stop2: "#FF7F00", // Rich orange
          stop3: "#E91E63", // Warm magenta
          stop4: "#9C27B0", // Purple
          stop5: "#483D8B", // Deep indigo
          blur: 200,
          centerOpacity: 1.0,
          edgeOpacity: 0.0,
          // Transform controls
          positionX: 0,
          positionY: 0,
          scale: 1.0,
          rotation: 0,
          skewX: 0,
          skewY: 0,
          // Feather control
          feather: 40,
          // Visual effects
          brightness: 1.0,
          contrast: 1.0,
          // Path data (stored as initial value)
          pathData:
            "M104,707.88c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,516.68,182.89,738.46,119.23,203.13-58.31,162.62-132.51,469.23-250,177.18-67.9,293.4-82.47,334.62-180.77,29.04-69.26,3.49-138.71-34.62-242.31-28.72-78.07-89.01-235.1-253.85-346.15C1534.34,70.06,1424.01-4.27,1273.23.19c-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-83.49,117.93-165.38,165.38-95.29,55.22-228.68,73.34-346.15,34.62-154.72-51-194.53-171.81-276.92-150-62.17,16.46-90.97,98.86-111.54,157.69-9.08,25.97-47.39,135.58,0,242.31,22.51,50.7,54.66,78.89,80.77,103.85Z",
        };

        const toRGB01 = (hex) => {
          const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex);
          if (!m) return [1, 1, 1];
          return [parseInt(m[1], 16) / 255, parseInt(m[2], 16) / 255, parseInt(m[3], 16) / 255];
        };

        function updateTables() {
          const colors = [params.stop1, params.stop2, params.stop3, params.stop4, params.stop5].map(toRGB01);
          const r = colors.map((c) => c[0].toFixed(3)).join(" ");
          const g = colors.map((c) => c[1].toFixed(3)).join(" ");
          const b = colors.map((c) => c[2].toFixed(3)).join(" ");
          document.getElementById("funcR")?.setAttribute("tableValues", r);
          document.getElementById("funcG")?.setAttribute("tableValues", g);
          document.getElementById("funcB")?.setAttribute("tableValues", b);
          const a = [params.centerOpacity, 0.95, 0.8, 0.55, params.edgeOpacity]
            .map((v) => Math.max(0, Math.min(1, v)).toFixed(2))
            .join(" ");
          document.getElementById("funcA")?.setAttribute("tableValues", a);
        }

        function updateBlur() {
          document.getElementById("dfBlur")?.setAttribute("stdDeviation", String(params.blur));
        }

        function updateTransform() {
          const useEl = document.getElementById("shapeUse");
          if (!useEl) return;
          const tx = params.positionX;
          const ty = params.positionY;
          const s = params.scale;
          const r = params.rotation;
          const skx = params.skewX;
          const sky = params.skewY;
          // Build transform string: translate → skew → rotate → scale
          useEl.setAttribute("transform", `translate(${tx}, ${ty}) skewX(${skx}) skewY(${sky}) rotate(${r}) scale(${s})`);
        }

        function updateFeather() {
          document.getElementById("featherBlur")?.setAttribute("stdDeviation", String(params.feather));
        }

        function updateEffects() {
          // Brightness: linear slope = brightness value
          // Contrast: use slope = contrast, intercept = -0.5 * contrast + 0.5
          const brightness = params.brightness;
          const contrast = params.contrast;
          const slope = brightness * contrast;
          const intercept = brightness * (-0.5 * contrast + 0.5);

          document.getElementById("brightnessR")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessR")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessG")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessG")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessB")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessB")?.setAttribute("intercept", String(intercept));
        }

        function updatePath() {
          const pathEl = document.getElementById("shapePath");
          if (pathEl && params.pathData.trim()) {
            try {
              pathEl.setAttribute("d", params.pathData);
            } catch (e) {
              console.error("Invalid path data:", e);
              alert("Invalid SVG path data. Please check the syntax.");
            }
          }
        }

        const cf = gui.addFolder("Colors (center → edge)");
        cf.addColor(params, "stop1").name("Stop 1").onChange(updateTables);
        cf.addColor(params, "stop2").name("Stop 2").onChange(updateTables);
        cf.addColor(params, "stop3").name("Stop 3").onChange(updateTables);
        cf.addColor(params, "stop4").name("Stop 4").onChange(updateTables);
        cf.addColor(params, "stop5").name("Stop 5").onChange(updateTables);
        const af = gui.addFolder("Alpha");
        af.add(params, "centerOpacity", 0, 1, 0.01).name("Center Opacity").onChange(updateTables);
        af.add(params, "edgeOpacity", 0, 1, 0.01).name("Edge Opacity").onChange(updateTables);
        gui.add(params, "blur", 50, 400, 1).name("Blur (spread)").onChange(updateBlur);

        const tf = gui.addFolder("Transform");
        tf.add(params, "positionX", -2000, 2000, 1).name("Position X").onChange(updateTransform);
        tf.add(params, "positionY", -2000, 2000, 1).name("Position Y").onChange(updateTransform);
        tf.add(params, "scale", 0.1, 3, 0.01).name("Scale").onChange(updateTransform);
        tf.add(params, "rotation", -180, 180, 1).name("Rotation (deg)").onChange(updateTransform);
        tf.add(params, "skewX", -45, 45, 0.5).name("Skew X (deg)").onChange(updateTransform);
        tf.add(params, "skewY", -45, 45, 0.5).name("Skew Y (deg)").onChange(updateTransform);

        const ff = gui.addFolder("Edge Feather");
        ff.add(params, "feather", 0, 150, 1).name("Feather Amount").onChange(updateFeather);

        const vf = gui.addFolder("Visual Effects");
        vf.add(params, "brightness", 0, 3, 0.01).name("Brightness").onChange(updateEffects);
        vf.add(params, "contrast", 0, 3, 0.01).name("Contrast").onChange(updateEffects);

        const pathf = gui.addFolder("Shape Path");
        const pathController = pathf.add(params, "pathData").name("Path Data (SVG d attribute)");
        pathController.onChange(updatePath);
        pathf.add({ update: () => updatePath() }, "update").name("Update Shape");

        // Store initial path on load
        params.pathData = document.getElementById("shapePath")?.getAttribute("d") || params.pathData;

        // Position GUI on the left
        setTimeout(() => {
          gui.domElement.style.position = "fixed";
          gui.domElement.style.top = "20px";
          gui.domElement.style.left = "20px";
          gui.domElement.style.zIndex = "1000";
        }, 100);

        updateTables();
        updateBlur();
        updateTransform();
        updateFeather();
        updateEffects();
      </script>
    </div>
  </body>
</html>
