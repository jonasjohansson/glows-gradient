<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>Glows Gradient</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0f0f0f;
      }
      .stage {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        overflow: hidden;
        background-image: url("cozy - 1291.jpg");
        background-size: cover;
        background-position: center top;
        background-repeat: no-repeat;
      }
      svg {
        width: min(90vw, 1200px);
        height: auto;
        display: block;
        overflow: visible;
      }

      #shapesGroup {
        filter: blur(0px);
        transition: filter 0.3s ease;
      }

      use[href="#shapePath"] {
        transform-origin: center;
        transform-box: fill-box;
      }
    </style>
  </head>
  <body>
    <div class="stage">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 1885.76 1161.29">
        <defs>
          <path
            id="shapePath"
            d="M104,707.88c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,516.68,182.89,738.46,119.23,203.13-58.31,162.62-132.51,469.23-250,177.18-67.9,293.4-82.47,334.62-180.77,29.04-69.26,3.49-138.71-34.62-242.31-28.72-78.07-89.01-235.1-253.85-346.15C1534.34,70.06,1424.01-4.27,1273.23.19c-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-83.49,117.93-165.38,165.38-95.29,55.22-228.68,73.34-346.15,34.62-154.72-51-194.53-171.81-276.92-150-62.17,16.46-90.97,98.86-111.54,157.69-9.08,25.97-47.39,135.58,0,242.31,22.51,50.7,54.66,78.89,80.77,103.85Z" />
          <path
            id="shapePath2"
            d="M1188.54,235.26c180.01,27.4,309.95,168.4,346.15,207.69,78.91,85.63,57.53,105.56,134.62,196.15,154.07,181.08,273.75,141.76,380.77,284.62,88.16,117.68,109.99,281.93,73.08,419.23-55.11,204.96-228.76,303.76-273.08,326.92-274.92,143.71-655.71,33.91-857.69-169.23-128.95-129.69-106.06-218.01-253.85-307.69-148.72-90.25-226.41-33.89-407.69-138.46-54.77-31.59-173.09-101.84-253.85-246.15C51.27,762.35-2.34,652.21.08,504.49,1.14,439.7,4.44,238.24,161.62,104.49,334.43-42.57,560.46,5.21,611.62,16.03c87.77,18.55,154.39,54.12,196.15,80.77" />

          <!-- Shared grain filter - applied after blob blur -->
          <filter
            id="grainFilter"
            filterUnits="userSpaceOnUse"
            x="-600"
            y="-600"
            width="3000"
            height="2400">
            <feImage
              id="sharedGrainImage"
              href="grain2.jpeg"
              result="sharedGrainTex"
              preserveAspectRatio="none" />
            <!-- Tile the grain texture to repeat across the filter area -->
            <feTile
              id="grainTile"
              in="sharedGrainTex"
              x="-600"
              y="-600"
              width="3000"
              height="2400"
              result="tiledGrainTex" />
            <!-- Offset for positioning the tiled grain -->
            <feOffset
              id="grainOffset"
              in="tiledGrainTex"
              dx="0"
              dy="0"
              result="offsetGrainTex" />
            <!-- Apply grain opacity -->
            <feComponentTransfer
              in="offsetGrainTex"
              result="sharedGrainWithOpacity">
              <feFuncA
                type="linear"
                slope="0"
                intercept="0"
                id="sharedGrainOpacityFunc" />
            </feComponentTransfer>
            <!-- Blend grain with source - use composite for multiply, feBlend for others -->
            <feBlend
              id="grainBlend"
              in="SourceGraphic"
              in2="offsetGrainTex"
              mode="overlay"
              result="grainBlended" />
            <!-- Multiply blend mode using arithmetic composite (result = i1 * i2) -->
            <feComposite
              id="grainMultiply"
              in="SourceGraphic"
              in2="offsetGrainTex"
              operator="arithmetic"
              k1="1"
              k2="0"
              k3="0"
              k4="0"
              result="grainMultiplied" />
            <!-- Select between feBlend result and multiply result based on mode -->
            <feComposite
              id="grainBlendSelector"
              in="grainBlended"
              in2="grainMultiplied"
              operator="over"
              result="grainBlendedFinal" />
            <!-- Composite with opacity control -->
            <feComposite
              in="SourceGraphic"
              in2="grainBlendedFinal"
              operator="arithmetic"
              k1="0"
              k2="0"
              k3="0"
              k4="0"
              id="grainComposite"
              result="finalGrain" />
          </filter>

          <!-- Create gradient filter for shape 1 -->
          <filter
            id="shapeGradient1"
            filterUnits="userSpaceOnUse"
            x="-600"
            y="-600"
            width="3000"
            height="2400">
            <!-- Organic displacement using turbulence -->
            <feTurbulence
              id="displaceTurbulence"
              type="fractalNoise"
              baseFrequency="0.01 0.01"
              numOctaves="5"
              result="turbulence"
              seed="1" />
            <feDisplacementMap
              id="displaceMap"
              in="SourceGraphic"
              in2="turbulence"
              scale="0"
              xChannelSelector="R"
              yChannelSelector="G"
              result="displaced" />

            <!-- Extract alpha from displaced shape -->
            <feColorMatrix
              in="displaced"
              type="matrix"
              values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0"
              result="displacedAlpha" />

            <!-- Blur SourceAlpha to create distance field: center is bright (1), edges fade to dark (0) -->
            <feGaussianBlur
              in="displacedAlpha"
              stdDeviation="200"
              result="blurred"
              id="dfBlur" />
            <!-- Invert so center = 0 (maps to red) and edge = 1 (maps to magenta) -->
            <feComponentTransfer
              in="blurred"
              result="inverted">
              <feFuncA
                type="table"
                tableValues="1 0" />
            </feComponentTransfer>
            <!-- Copy alpha channel to RGB so we can map colors based on intensity -->
            <feColorMatrix
              in="inverted"
              type="matrix"
              values="0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 0"
              result="grayRGB" />

            <!-- Rainbow mapping from center → edges using table-based RGB lookups -->
            <!-- Order (center to edge): red → orange → yellow → green → cyan → blue → magenta
                 The alpha fades outward so it dissolves into the background. -->
            <feComponentTransfer
              in="grayRGB"
              result="gradient">
              <!-- R:  red(1) → orange(1) → yellow(1) → green(0) → cyan(0) → blue(0) → magenta(1) -->
              <feFuncR
                type="table"
                tableValues="1 1 1 0 0 0 1"
                id="funcR1" />
              <!-- G:  red(0) → orange(0.5) → yellow(1) → green(1) → cyan(1) → blue(0) → magenta(0) -->
              <feFuncG
                type="table"
                tableValues="0 0.5 1 1 1 0 0"
                id="funcG1" />
              <!-- B:  red(0) → orange(0) → yellow(0) → green(0) → cyan(1) → blue(1) → magenta(1) -->
              <feFuncB
                type="table"
                tableValues="0 0 0 0 1 1 1"
                id="funcB1" />
              <!-- Alpha: keep bright in center, fade gradually to edge -->
              <feFuncA
                type="table"
                tableValues="1.0 1.0 0.95 0.85 0.7 0.4 0.0"
                id="funcA1" />
            </feComponentTransfer>

            <!-- Extra feather: blur the displaced alpha and use as a soft edge mask -->
            <feGaussianBlur
              id="featherBlur"
              in="displacedAlpha"
              stdDeviation="40"
              result="featherMask" />
            <feComposite
              in="gradient"
              in2="featherMask"
              operator="in"
              result="feathered" />

            <!-- Brightness and Contrast adjustments -->
            <feComponentTransfer
              in="feathered"
              result="final">
              <feFuncR
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessR1" />
              <feFuncG
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessG1" />
              <feFuncB
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessB1" />
            </feComponentTransfer>
            <!-- Final result before grain (grain applied externally after blur) -->
          </filter>

          <!-- Create gradient filter for shape 2 (duplicate of shape 1) -->
          <filter
            id="shapeGradient2"
            filterUnits="userSpaceOnUse"
            x="-600"
            y="-600"
            width="3000"
            height="2400">
            <!-- Organic displacement using turbulence -->
            <feTurbulence
              id="displaceTurbulence2"
              type="fractalNoise"
              baseFrequency="0.01 0.01"
              numOctaves="5"
              result="turbulence2"
              seed="1" />
            <feDisplacementMap
              id="displaceMap2"
              in="SourceGraphic"
              in2="turbulence2"
              scale="0"
              xChannelSelector="R"
              yChannelSelector="G"
              result="displaced2" />

            <!-- Extract alpha from displaced shape -->
            <feColorMatrix
              in="displaced2"
              type="matrix"
              values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0"
              result="displacedAlpha2" />

            <!-- Blur SourceAlpha to create distance field: center is bright (1), edges fade to dark (0) -->
            <feGaussianBlur
              in="displacedAlpha2"
              stdDeviation="200"
              result="blurred2"
              id="dfBlur2" />
            <!-- Invert so center = 0 (maps to red) and edge = 1 (maps to magenta) -->
            <feComponentTransfer
              in="blurred2"
              result="inverted2">
              <feFuncA
                type="table"
                tableValues="1 0" />
            </feComponentTransfer>
            <!-- Copy alpha channel to RGB so we can map colors based on intensity -->
            <feColorMatrix
              in="inverted2"
              type="matrix"
              values="0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 0"
              result="grayRGB2" />

            <!-- Rainbow mapping from center → edges using table-based RGB lookups -->
            <feComponentTransfer
              in="grayRGB2"
              result="gradient2">
              <!-- R:  red(1) → orange(1) → yellow(1) → green(0) → cyan(0) → blue(0) → magenta(1) -->
              <feFuncR
                type="table"
                tableValues="1 1 1 0 0 0 1"
                id="funcR2" />
              <!-- G:  red(0) → orange(0.5) → yellow(1) → green(1) → cyan(1) → blue(0) → magenta(0) -->
              <feFuncG
                type="table"
                tableValues="0 0.5 1 1 1 0 0"
                id="funcG2" />
              <!-- B:  red(0) → orange(0) → yellow(0) → green(0) → cyan(1) → blue(1) → magenta(1) -->
              <feFuncB
                type="table"
                tableValues="0 0 0 0 1 1 1"
                id="funcB2" />
              <!-- Alpha: keep bright in center, fade gradually to edge -->
              <feFuncA
                type="table"
                tableValues="1.0 1.0 0.95 0.85 0.7 0.4 0.0"
                id="funcA2" />
            </feComponentTransfer>

            <!-- Extra feather: blur the displaced alpha and use as a soft edge mask -->
            <feGaussianBlur
              id="featherBlur2"
              in="displacedAlpha2"
              stdDeviation="40"
              result="featherMask2" />
            <feComposite
              in="gradient2"
              in2="featherMask2"
              operator="in"
              result="feathered2" />

            <!-- Brightness and Contrast adjustments -->
            <feComponentTransfer
              in="feathered2"
              result="final2">
              <feFuncR
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessR2" />
              <feFuncG
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessG2" />
              <feFuncB
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessB2" />
            </feComponentTransfer>
            <!-- Final result before grain (grain applied externally after blur) -->
          </filter>
        </defs>

        <!-- Apply gradient filter -->
        <!-- Grain filter will be applied after blob blur via JavaScript -->
        <g id="shapesGroup">
          <use
            id="shapeUse"
            href="#shapePath"
            fill="white"
            filter="url(#shapeGradient1)" />
          <use
            id="shapeUse2"
            href="#shapePath2"
            fill="white"
            filter="url(#shapeGradient2)" />
        </g>
      </svg>
      <!-- lil-gui -->
      <script type="module">
        import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.21/+esm";
        const gui = new GUI();
        const params = {
          // Five color stops from center→edge - Shape 1
          stop1_1: "#FFD700", // Bright golden yellow
          stop2_1: "#FF7F00", // Rich orange
          stop3_1: "#E91E63", // Warm magenta
          stop4_1: "#9C27B0", // Purple
          stop5_1: "#483D8B", // Deep indigo
          // Color stop positions (0-1, center to edge) - Shape 1
          stopPos1_1: 0.0,
          stopPos2_1: 0.2,
          stopPos3_1: 0.5,
          stopPos4_1: 0.8,
          stopPos5_1: 1.0,
          // Five color stops from center→edge - Shape 2
          stop1_2: "#FFD700", // Bright golden yellow
          stop2_2: "#FF7F00", // Rich orange
          stop3_2: "#E91E63", // Warm magenta
          stop4_2: "#9C27B0", // Purple
          stop5_2: "#483D8B", // Deep indigo
          // Color stop positions (0-1, center to edge) - Shape 2
          stopPos1_2: 0.0,
          stopPos2_2: 0.2,
          stopPos3_2: 0.5,
          stopPos4_2: 0.8,
          stopPos5_2: 1.0,
          blur: 200,
          centerOpacity1: 1.0,
          edgeOpacity1: 0.0,
          centerOpacity2: 1.0,
          edgeOpacity2: 0.0,
          // Transform controls - Shape 1
          positionX1: 0,
          positionY1: 0,
          scale1: 1.0,
          rotation1: 0,
          skewX1: 0,
          skewY1: 0,
          // Transform controls - Shape 2
          positionX2: 0,
          positionY2: 0,
          scale2: 1.0,
          rotation2: 0,
          skewX2: 0,
          skewY2: 0,
          // Blob effect
          blobBlur: 0,
          // Blending
          blendMode1: "normal",
          blendMode2: "normal",
          // Grain overlay
          grainOpacity: 0,
          grainBlend: "overlay",
          grainScale: 1.0,
          grainPositionX: 0,
          grainPositionY: 0,
          // Animation
          animate: false,
          animationSpeed: 1.0,
          animationIntensity: 5,
          animationRandomness: 1.0,
          // Feather control
          feather: 40,
          // Visual effects
          brightness: 1.0,
          contrast: 1.0,
          // Displacement controls
          displacementStrength: 0,
          displacementFrequency: 0.01,
          displacementOctaves: 5,
          displacementAnimated: false,
          displacementSpeed: 0.005,
          // Path data (stored as initial value)
          pathData:
            "M104,707.88c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,516.68,182.89,738.46,119.23,203.13-58.31,162.62-132.51,469.23-250,177.18-67.9,293.4-82.47,334.62-180.77,29.04-69.26,3.49-138.71-34.62-242.31-28.72-78.07-89.01-235.1-253.85-346.15C1534.34,70.06,1424.01-4.27,1273.23.19c-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-83.49,117.93-165.38,165.38-95.29,55.22-228.68,73.34-346.15,34.62-154.72-51-194.53-171.81-276.92-150-62.17,16.46-90.97,98.86-111.54,157.69-9.08,25.97-47.39,135.58,0,242.31,22.51,50.7,54.66,78.89,80.77,103.85Z",
          pathData2:
            "M80.94,728.19c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,528.22,713.66,750,650,203.13-58.31,151.08-663.28,457.69-780.77,177.18-67.9-210.44,2.15-169.23-96.15,29.04-69.26,507.34-223.32,469.23-326.92-28.72-78.07-89.01-235.1-253.85-346.15-50.43-33.97-160.76-108.31-311.54-103.85-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-287.34-216.68-369.23-169.23-95.29,55.22-24.83,407.95-142.31,369.23-154.72-51,93.94,139.72,11.54,161.54C338.01,552.34,20.74,323.2.18,382.04c-9.08,25.97,337.22,339.42,384.62,446.15,22.51,50.7-329.96-124.96-303.85-100Z",
        };

        const toRGB01 = (hex) => {
          const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex);
          if (!m) return [1, 1, 1];
          return [parseInt(m[1], 16) / 255, parseInt(m[2], 16) / 255, parseInt(m[3], 16) / 255];
        };

        function interpolateColorStops(colors, positions) {
          // Create an array of 256 entries (0-255) representing the gradient
          const result = new Array(256);
          const numStops = colors.length;

          for (let i = 0; i < 256; i++) {
            const t = i / 255; // Normalize to 0-1

            // Find which two stops to interpolate between
            let stopIndex = 0;
            for (let j = 0; j < numStops - 1; j++) {
              if (t >= positions[j] && t <= positions[j + 1]) {
                stopIndex = j;
                break;
              }
            }

            // Clamp to last stop if beyond
            if (t > positions[numStops - 1]) {
              stopIndex = numStops - 2;
            }

            const pos1 = positions[stopIndex];
            const pos2 = positions[stopIndex + 1];
            const color1 = colors[stopIndex];
            const color2 = colors[stopIndex + 1];

            // Interpolate between the two stops
            const range = pos2 - pos1;
            const localT = range > 0 ? (t - pos1) / range : 0;

            result[i] = [
              color1[0] + (color2[0] - color1[0]) * localT,
              color1[1] + (color2[1] - color1[1]) * localT,
              color1[2] + (color2[2] - color1[2]) * localT,
            ];
          }

          // Sample 7 points evenly to create table values
          const samplePoints = [0, 42, 85, 128, 170, 213, 255];
          return samplePoints.map((idx) => result[idx]);
        }

        function updateTables1() {
          const colors = [params.stop1_1, params.stop2_1, params.stop3_1, params.stop4_1, params.stop5_1].map(toRGB01);
          const positions = [params.stopPos1_1, params.stopPos2_1, params.stopPos3_1, params.stopPos4_1, params.stopPos5_1]
            .map((p) => Math.max(0, Math.min(1, p)))
            .sort((a, b) => a - b);

          // Ensure positions are sorted and clamp colors accordingly
          const sortedPairs = positions.map((p, i) => ({ pos: p, color: colors[i] })).sort((a, b) => a.pos - b.pos);
          const sortedColors = sortedPairs.map((p) => p.color);
          const sortedPositions = sortedPairs.map((p) => p.pos);

          // Interpolate to create smooth gradient
          const interpolated = interpolateColorStops(sortedColors, sortedPositions);

          const r = interpolated.map((c) => c[0].toFixed(3)).join(" ");
          const g = interpolated.map((c) => c[1].toFixed(3)).join(" ");
          const b = interpolated.map((c) => c[2].toFixed(3)).join(" ");

          document.getElementById("funcR1")?.setAttribute("tableValues", r);
          document.getElementById("funcG1")?.setAttribute("tableValues", g);
          document.getElementById("funcB1")?.setAttribute("tableValues", b);

          // Interpolate alpha based on stop positions
          const alphaStops = [params.centerOpacity1, 0.95, 0.8, 0.55, params.edgeOpacity1];
          const alphaInterpolated = interpolateColorStops(
            alphaStops.map((a) => [a, a, a]),
            sortedPositions
          );
          const a = alphaInterpolated.map((c) => Math.max(0, Math.min(1, c[0])).toFixed(2)).join(" ");
          document.getElementById("funcA1")?.setAttribute("tableValues", a);
        }

        function updateTables2() {
          const colors = [params.stop1_2, params.stop2_2, params.stop3_2, params.stop4_2, params.stop5_2].map(toRGB01);
          const positions = [params.stopPos1_2, params.stopPos2_2, params.stopPos3_2, params.stopPos4_2, params.stopPos5_2]
            .map((p) => Math.max(0, Math.min(1, p)))
            .sort((a, b) => a - b);

          // Ensure positions are sorted and clamp colors accordingly
          const sortedPairs = positions.map((p, i) => ({ pos: p, color: colors[i] })).sort((a, b) => a.pos - b.pos);
          const sortedColors = sortedPairs.map((p) => p.color);
          const sortedPositions = sortedPairs.map((p) => p.pos);

          // Interpolate to create smooth gradient
          const interpolated = interpolateColorStops(sortedColors, sortedPositions);

          const r = interpolated.map((c) => c[0].toFixed(3)).join(" ");
          const g = interpolated.map((c) => c[1].toFixed(3)).join(" ");
          const b = interpolated.map((c) => c[2].toFixed(3)).join(" ");

          document.getElementById("funcR2")?.setAttribute("tableValues", r);
          document.getElementById("funcG2")?.setAttribute("tableValues", g);
          document.getElementById("funcB2")?.setAttribute("tableValues", b);

          // Interpolate alpha based on stop positions
          const alphaStops = [params.centerOpacity2, 0.95, 0.8, 0.55, params.edgeOpacity2];
          const alphaInterpolated = interpolateColorStops(
            alphaStops.map((a) => [a, a, a]),
            sortedPositions
          );
          const a = alphaInterpolated.map((c) => Math.max(0, Math.min(1, c[0])).toFixed(2)).join(" ");
          document.getElementById("funcA2")?.setAttribute("tableValues", a);
        }

        function updateBlur() {
          document.getElementById("dfBlur")?.setAttribute("stdDeviation", String(params.blur));
          document.getElementById("dfBlur2")?.setAttribute("stdDeviation", String(params.blur));
        }

        function updateTransform1() {
          const useEl = document.getElementById("shapeUse");
          if (!useEl) return;
          // Base transforms are stored in params, animation adds offsets
          const tx = params.positionX1;
          const ty = params.positionY1;
          const s = params.scale1;
          const r = params.rotation1;
          const skx = params.skewX1;
          const sky = params.skewY1;
          // Build transform string: translate → skew → rotate → scale
          const transform = `translate(${tx}, ${ty}) skewX(${skx}) skewY(${sky}) rotate(${r}) scale(${s})`;
          useEl.setAttribute("transform", transform);
        }

        function updateTransform2() {
          const useEl2 = document.getElementById("shapeUse2");
          if (!useEl2) return;
          // Base transforms are stored in params, animation adds offsets
          const tx = params.positionX2;
          const ty = params.positionY2;
          const s = params.scale2;
          const r = params.rotation2;
          const skx = params.skewX2;
          const sky = params.skewY2;
          // Build transform string: translate → skew → rotate → scale
          const transform = `translate(${tx}, ${ty}) skewX(${skx}) skewY(${sky}) rotate(${r}) scale(${s})`;
          useEl2.setAttribute("transform", transform);
        }

        function updateBlendModes() {
          const shape1 = document.getElementById("shapeUse");
          const shape2 = document.getElementById("shapeUse2");
          if (shape1) {
            shape1.style.mixBlendMode = params.blendMode1;
          }
          if (shape2) {
            shape2.style.mixBlendMode = params.blendMode2;
          }
        }

        function updateGrain() {
          // Update grain texture scale (smaller dimensions = more tiles, larger = fewer tiles)
          const scale = Math.max(0.1, params.grainScale);
          // Base size for the texture - adjust these to match your texture's aspect ratio
          const baseTextureSize = 200; // Base size for the texture tile
          const scaledSize = baseTextureSize / scale;

          const sharedGrainImage = document.getElementById("sharedGrainImage");
          if (sharedGrainImage) {
            // Set width and height to control tile size (smaller = more repetitions)
            sharedGrainImage.setAttribute("width", String(scaledSize));
            sharedGrainImage.setAttribute("height", String(scaledSize));
          }

          // Update grain position offset
          const grainOffset = document.getElementById("grainOffset");
          if (grainOffset) {
            grainOffset.setAttribute("dx", String(params.grainPositionX));
            grainOffset.setAttribute("dy", String(params.grainPositionY));
          }

          // Update grain opacity
          const sharedGrainOpacityFunc = document.getElementById("sharedGrainOpacityFunc");
          if (sharedGrainOpacityFunc) {
            sharedGrainOpacityFunc.setAttribute("intercept", String(params.grainOpacity));
          }

          // Update arithmetic composite for opacity interpolation
          const opacity = params.grainOpacity;
          const k2 = 1 - opacity;
          const k3 = opacity;

          const grainComposite = document.getElementById("grainComposite");
          if (grainComposite) {
            grainComposite.setAttribute("k2", String(k2));
            grainComposite.setAttribute("k3", String(k3));
          }

          // Update grain blend mode
          const grainBlend = document.getElementById("grainBlend");
          const grainBlendSelector = document.getElementById("grainBlendSelector");

          if (params.grainBlend === "multiply") {
            // Use arithmetic composite for multiply (result = i1 * i2)
            // The grainMultiply composite already does this with k1=1
            if (grainBlendSelector) {
              // Select the multiply result
              grainBlendSelector.setAttribute("operator", "arithmetic");
              grainBlendSelector.setAttribute("k1", "0");
              grainBlendSelector.setAttribute("k2", "0");
              grainBlendSelector.setAttribute("k3", "1"); // Use in2 (grainMultiplied)
              grainBlendSelector.setAttribute("k4", "0");
              grainBlendSelector.setAttribute("in", "SourceGraphic");
              grainBlendSelector.setAttribute("in2", "grainMultiplied");
            }
          } else {
            // Use feBlend for other modes
            const blendModeMap = {
              normal: "normal",
              screen: "screen",
              darken: "darken",
              lighten: "lighten",
              overlay: "multiply", // approximate
              "soft-light": "multiply",
              "hard-light": "multiply",
              "color-dodge": "screen",
              "color-burn": "darken",
              difference: "normal",
              exclusion: "normal",
            };

            const svgBlendMode = blendModeMap[params.grainBlend] || "normal";
            if (grainBlend) {
              grainBlend.setAttribute("mode", svgBlendMode);
            }
            if (grainBlendSelector) {
              // Show blend result - pass through grainBlended
              grainBlendSelector.setAttribute("operator", "arithmetic");
              grainBlendSelector.setAttribute("k1", "0");
              grainBlendSelector.setAttribute("k2", "0");
              grainBlendSelector.setAttribute("k3", "1"); // Use in2 (grainBlended)
              grainBlendSelector.setAttribute("k4", "0");
              grainBlendSelector.setAttribute("in", "SourceGraphic");
              grainBlendSelector.setAttribute("in2", "grainBlended");
            }
          }

          // Apply grain filter after blob blur
          const shapesGroup = document.getElementById("shapesGroup");
          if (shapesGroup && params.grainOpacity > 0) {
            // Apply grain filter and blob blur together
            const blobBlur = params.blobBlur > 0 ? `blur(${params.blobBlur}px)` : "";
            const grainFilter = `url(#grainFilter)`;
            shapesGroup.style.filter = blobBlur ? `${blobBlur} ${grainFilter}` : grainFilter;
          } else if (shapesGroup) {
            // Only blob blur if grain is off
            shapesGroup.style.filter = params.blobBlur > 0 ? `blur(${params.blobBlur}px)` : "none";
          }
        }

        function updateBlobBlur() {
          updateGrain(); // Grain needs to be reapplied with blob blur
        }

        function updateFeather() {
          document.getElementById("featherBlur")?.setAttribute("stdDeviation", String(params.feather));
          document.getElementById("featherBlur2")?.setAttribute("stdDeviation", String(params.feather));
        }

        function updateEffects() {
          // Brightness: linear slope = brightness value
          // Contrast: use slope = contrast, intercept = -0.5 * contrast + 0.5
          const brightness = params.brightness;
          const contrast = params.contrast;
          const slope = brightness * contrast;
          const intercept = brightness * (-0.5 * contrast + 0.5);

          // Apply to both shapes (shared brightness/contrast for now)
          document.getElementById("brightnessR1")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessR1")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessG1")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessG1")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessB1")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessB1")?.setAttribute("intercept", String(intercept));

          document.getElementById("brightnessR2")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessR2")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessG2")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessG2")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessB2")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessB2")?.setAttribute("intercept", String(intercept));
        }

        let displacementAnimationId = null;

        let displacementTime = 0;

        function updateDisplacement() {
          // Update both displacement maps
          document.getElementById("displaceMap")?.setAttribute("scale", String(params.displacementStrength));
          document.getElementById("displaceMap2")?.setAttribute("scale", String(params.displacementStrength));

          const freq = params.displacementFrequency;
          document.getElementById("displaceTurbulence")?.setAttribute("baseFrequency", `${freq} ${freq}`);
          document.getElementById("displaceTurbulence")?.setAttribute("numOctaves", String(params.displacementOctaves));
          document.getElementById("displaceTurbulence2")?.setAttribute("baseFrequency", `${freq} ${freq}`);
          document.getElementById("displaceTurbulence2")?.setAttribute("numOctaves", String(params.displacementOctaves));

          // Stop existing animation
          if (displacementAnimationId) {
            cancelAnimationFrame(displacementAnimationId);
            displacementAnimationId = null;
          }

          // Start animated displacement if enabled - lava lamp style
          if (params.displacementAnimated && params.displacementStrength > 0) {
            function animate() {
              displacementTime += params.displacementSpeed || 0.005;
              const baseFreq = params.displacementFrequency;
              const turbEl = document.getElementById("displaceTurbulence");
              const turbEl2 = document.getElementById("displaceTurbulence2");
              if (turbEl && turbEl2) {
                // Lava lamp style: slow, smooth, flowing movement
                // Multiple sine waves at different frequencies for organic flow
                const wave1 = Math.sin(displacementTime * 0.3) * 0.003;
                const wave2 = Math.cos(displacementTime * 0.5) * 0.005;
                const wave3 = Math.sin(displacementTime * 0.7 + 1.5) * 0.002;

                const x = baseFreq + wave1 + wave2;
                const y = baseFreq + wave3 + Math.cos(displacementTime * 0.4) * 0.004;
                turbEl.setAttribute("baseFrequency", `${x} ${y}`);
                // Shape 2 with slight phase offset for variation
                const x2 = baseFreq + Math.sin(displacementTime * 0.3 + 1.0) * 0.003;
                const y2 = baseFreq + Math.cos(displacementTime * 0.5 + 0.5) * 0.005;
                turbEl2.setAttribute("baseFrequency", `${x2} ${y2}`);
              }
              displacementAnimationId = requestAnimationFrame(animate);
            }
            animate();
          } else {
            // Reset when not animated
            displacementTime = 0;
          }
        }

        function updatePath() {
          const pathEl = document.getElementById("shapePath");
          if (pathEl && params.pathData.trim()) {
            try {
              pathEl.setAttribute("d", params.pathData);
            } catch (e) {
              console.error("Invalid path data:", e);
              alert("Invalid SVG path data. Please check the syntax.");
            }
          }
        }

        function updatePath2() {
          const pathEl = document.getElementById("shapePath2");
          if (pathEl && params.pathData2.trim()) {
            try {
              pathEl.setAttribute("d", params.pathData2);
            } catch (e) {
              console.error("Invalid path data:", e);
              alert("Invalid SVG path data. Please check the syntax.");
            }
          }
        }

        const cf1 = gui.addFolder("Shape 1 Colors (center → edge)");
        cf1.addColor(params, "stop1_1").name("Stop 1").onChange(updateTables1);
        cf1.addColor(params, "stop2_1").name("Stop 2").onChange(updateTables1);
        cf1.addColor(params, "stop3_1").name("Stop 3").onChange(updateTables1);
        cf1.addColor(params, "stop4_1").name("Stop 4").onChange(updateTables1);
        cf1.addColor(params, "stop5_1").name("Stop 5").onChange(updateTables1);
        const sp1 = gui.addFolder("Shape 1 Stop Positions");
        sp1.add(params, "stopPos1_1", 0, 1, 0.01).name("Stop 1 Position").onChange(updateTables1);
        sp1.add(params, "stopPos2_1", 0, 1, 0.01).name("Stop 2 Position").onChange(updateTables1);
        sp1.add(params, "stopPos3_1", 0, 1, 0.01).name("Stop 3 Position").onChange(updateTables1);
        sp1.add(params, "stopPos4_1", 0, 1, 0.01).name("Stop 4 Position").onChange(updateTables1);
        sp1.add(params, "stopPos5_1", 0, 1, 0.01).name("Stop 5 Position").onChange(updateTables1);
        const af1 = gui.addFolder("Shape 1 Alpha");
        af1.add(params, "centerOpacity1", 0, 1, 0.01).name("Center Opacity").onChange(updateTables1);
        af1.add(params, "edgeOpacity1", 0, 1, 0.01).name("Edge Opacity").onChange(updateTables1);

        const cf2 = gui.addFolder("Shape 2 Colors (center → edge)");
        cf2.addColor(params, "stop1_2").name("Stop 1").onChange(updateTables2);
        cf2.addColor(params, "stop2_2").name("Stop 2").onChange(updateTables2);
        cf2.addColor(params, "stop3_2").name("Stop 3").onChange(updateTables2);
        cf2.addColor(params, "stop4_2").name("Stop 4").onChange(updateTables2);
        cf2.addColor(params, "stop5_2").name("Stop 5").onChange(updateTables2);
        const sp2 = gui.addFolder("Shape 2 Stop Positions");
        sp2.add(params, "stopPos1_2", 0, 1, 0.01).name("Stop 1 Position").onChange(updateTables2);
        sp2.add(params, "stopPos2_2", 0, 1, 0.01).name("Stop 2 Position").onChange(updateTables2);
        sp2.add(params, "stopPos3_2", 0, 1, 0.01).name("Stop 3 Position").onChange(updateTables2);
        sp2.add(params, "stopPos4_2", 0, 1, 0.01).name("Stop 4 Position").onChange(updateTables2);
        sp2.add(params, "stopPos5_2", 0, 1, 0.01).name("Stop 5 Position").onChange(updateTables2);
        const af2 = gui.addFolder("Shape 2 Alpha");
        af2.add(params, "centerOpacity2", 0, 1, 0.01).name("Center Opacity").onChange(updateTables2);
        af2.add(params, "edgeOpacity2", 0, 1, 0.01).name("Edge Opacity").onChange(updateTables2);

        gui.add(params, "blur", 50, 400, 1).name("Blur (spread)").onChange(updateBlur);

        const tf1 = gui.addFolder("Shape 1 Transform");
        tf1.add(params, "positionX1", -2000, 2000, 1).name("Position X").onChange(updateTransform1);
        tf1.add(params, "positionY1", -2000, 2000, 1).name("Position Y").onChange(updateTransform1);
        tf1.add(params, "scale1", 0.1, 3, 0.01).name("Scale").onChange(updateTransform1);
        tf1.add(params, "rotation1", -180, 180, 1).name("Rotation (deg)").onChange(updateTransform1);
        tf1.add(params, "skewX1", -45, 45, 0.5).name("Skew X (deg)").onChange(updateTransform1);
        tf1.add(params, "skewY1", -45, 45, 0.5).name("Skew Y (deg)").onChange(updateTransform1);

        const tf2 = gui.addFolder("Shape 2 Transform");
        tf2.add(params, "positionX2", -2000, 2000, 1).name("Position X").onChange(updateTransform2);
        tf2.add(params, "positionY2", -2000, 2000, 1).name("Position Y").onChange(updateTransform2);
        tf2.add(params, "scale2", 0.1, 3, 0.01).name("Scale").onChange(updateTransform2);
        tf2.add(params, "rotation2", -180, 180, 1).name("Rotation (deg)").onChange(updateTransform2);
        tf2.add(params, "skewX2", -45, 45, 0.5).name("Skew X (deg)").onChange(updateTransform2);
        tf2.add(params, "skewY2", -45, 45, 0.5).name("Skew Y (deg)").onChange(updateTransform2);

        const bf = gui.addFolder("Blob Effect");
        bf.add(params, "blobBlur", 0, 200, 1).name("Blob Blur").onChange(updateBlobBlur);

        // Animation
        let animationId = null;
        let baseTransform1 = { x: 0, y: 0, rotation: 0 };
        let baseTransform2 = { x: 0, y: 0, rotation: 0 };
        let animationTime = 0;

        function startAnimation() {
          if (animationId) cancelAnimationFrame(animationId);

          if (params.animate) {
            function animate() {
              animationTime += 0.01 * (params.animationSpeed || 1.0);

              // Randomness factor - uses additional wave frequencies for smooth randomness
              const randomness = params.animationRandomness;
              const baseIntensity = params.animationIntensity;

              // Generate multiple wave components for smooth randomness (no stuttering)
              // Shape 1 - multiple frequency waves with randomness as additional wave layers
              const wave1X = Math.sin(animationTime * 0.7);
              const wave2X = Math.cos(animationTime * 1.3);
              const wave3X = Math.sin(animationTime * 2.1);
              // Additional waves for randomness - smooth continuous variation
              const randomWave1X = Math.sin(animationTime * (3.7 + randomness * 0.3));
              const randomWave2X = Math.cos(animationTime * (4.1 + randomness * 0.5));
              const randomWave3X = Math.sin(animationTime * (5.3 + randomness * 0.4));
              const noiseX = (randomWave1X * 0.4 + randomWave2X * 0.35 + randomWave3X * 0.25) * randomness;
              const offsetX1 = (wave1X * 0.5 + wave2X * 0.3 + wave3X * 0.2 + noiseX * 0.3) * baseIntensity;

              const wave1Y = Math.cos(animationTime * 0.9);
              const wave2Y = Math.sin(animationTime * 1.5);
              const wave3Y = Math.cos(animationTime * 2.3);
              const randomWave1Y = Math.cos(animationTime * (3.9 + randomness * 0.4));
              const randomWave2Y = Math.sin(animationTime * (4.3 + randomness * 0.6));
              const randomWave3Y = Math.cos(animationTime * (5.7 + randomness * 0.3));
              const noiseY = (randomWave1Y * 0.4 + randomWave2Y * 0.35 + randomWave3Y * 0.25) * randomness;
              const offsetY1 = (wave1Y * 0.5 + wave2Y * 0.3 + wave3Y * 0.2 + noiseY * 0.3) * baseIntensity;

              const wave1R = Math.sin(animationTime * 0.5);
              const wave2R = Math.cos(animationTime * 1.1);
              const randomWave1R = Math.sin(animationTime * (3.5 + randomness * 0.25));
              const randomWave2R = Math.cos(animationTime * (4.7 + randomness * 0.35));
              const noiseR = (randomWave1R * 0.5 + randomWave2R * 0.5) * randomness;
              const rotation1 = (wave1R * 0.6 + wave2R * 0.4 + noiseR * 0.2) * baseIntensity * 0.5;

              // Shape 2 - different frequencies + smooth randomness waves
              const wave1X2 = Math.cos(animationTime * 0.8);
              const wave2X2 = Math.sin(animationTime * 1.4);
              const wave3X2 = Math.cos(animationTime * 2.2);
              const randomWave1X2 = Math.cos(animationTime * (3.8 + randomness * 0.35));
              const randomWave2X2 = Math.sin(animationTime * (4.2 + randomness * 0.45));
              const randomWave3X2 = Math.cos(animationTime * (5.4 + randomness * 0.4));
              const noiseX2 = (randomWave1X2 * 0.4 + randomWave2X2 * 0.35 + randomWave3X2 * 0.25) * randomness;
              const offsetX2 = (wave1X2 * 0.5 + wave2X2 * 0.3 + wave3X2 * 0.2 + noiseX2 * 0.3) * baseIntensity;

              const wave1Y2 = Math.sin(animationTime * 0.6);
              const wave2Y2 = Math.cos(animationTime * 1.2);
              const wave3Y2 = Math.sin(animationTime * 2.4);
              const randomWave1Y2 = Math.sin(animationTime * (4.0 + randomness * 0.3));
              const randomWave2Y2 = Math.cos(animationTime * (4.4 + randomness * 0.5));
              const randomWave3Y2 = Math.sin(animationTime * (5.8 + randomness * 0.35));
              const noiseY2 = (randomWave1Y2 * 0.4 + randomWave2Y2 * 0.35 + randomWave3Y2 * 0.25) * randomness;
              const offsetY2 = (wave1Y2 * 0.5 + wave2Y2 * 0.3 + wave3Y2 * 0.2 + noiseY2 * 0.3) * baseIntensity;

              const wave1R2 = Math.cos(animationTime * 0.4);
              const wave2R2 = Math.sin(animationTime * 1.0);
              const randomWave1R2 = Math.cos(animationTime * (3.6 + randomness * 0.3));
              const randomWave2R2 = Math.sin(animationTime * (4.8 + randomness * 0.4));
              const noiseR2 = (randomWave1R2 * 0.5 + randomWave2R2 * 0.5) * randomness;
              const rotation2 = (wave1R2 * 0.6 + wave2R2 * 0.4 + noiseR2 * 0.2) * baseIntensity * 0.5;

              // Animated skew offsets - Shape 1
              const wave1SkewX = Math.sin(animationTime * 0.6);
              const wave2SkewX = Math.cos(animationTime * 1.2);
              const randomWave1SkewX = Math.sin(animationTime * (4.1 + randomness * 0.3));
              const randomWave2SkewX = Math.cos(animationTime * (4.9 + randomness * 0.4));
              const noiseSkewX = (randomWave1SkewX * 0.5 + randomWave2SkewX * 0.5) * randomness;
              const skewXOffset1 = (wave1SkewX * 0.6 + wave2SkewX * 0.4 + noiseSkewX * 0.2) * baseIntensity * 0.3;

              const wave1SkewY = Math.cos(animationTime * 0.65);
              const wave2SkewY = Math.sin(animationTime * 1.25);
              const randomWave1SkewY = Math.cos(animationTime * (4.2 + randomness * 0.35));
              const randomWave2SkewY = Math.sin(animationTime * (5.1 + randomness * 0.45));
              const noiseSkewY = (randomWave1SkewY * 0.5 + randomWave2SkewY * 0.5) * randomness;
              const skewYOffset1 = (wave1SkewY * 0.6 + wave2SkewY * 0.4 + noiseSkewY * 0.2) * baseIntensity * 0.3;

              // Animated skew offsets - Shape 2
              const wave1SkewX2 = Math.cos(animationTime * 0.55);
              const wave2SkewX2 = Math.sin(animationTime * 1.15);
              const randomWave1SkewX2 = Math.cos(animationTime * (4.3 + randomness * 0.32));
              const randomWave2SkewX2 = Math.sin(animationTime * (5.0 + randomness * 0.42));
              const noiseSkewX2 = (randomWave1SkewX2 * 0.5 + randomWave2SkewX2 * 0.5) * randomness;
              const skewXOffset2 = (wave1SkewX2 * 0.6 + wave2SkewX2 * 0.4 + noiseSkewX2 * 0.2) * baseIntensity * 0.3;

              const wave1SkewY2 = Math.sin(animationTime * 0.58);
              const wave2SkewY2 = Math.cos(animationTime * 1.22);
              const randomWave1SkewY2 = Math.sin(animationTime * (4.4 + randomness * 0.38));
              const randomWave2SkewY2 = Math.cos(animationTime * (5.2 + randomness * 0.48));
              const noiseSkewY2 = (randomWave1SkewY2 * 0.5 + randomWave2SkewY2 * 0.5) * randomness;
              const skewYOffset2 = (wave1SkewY2 * 0.6 + wave2SkewY2 * 0.4 + noiseSkewY2 * 0.2) * baseIntensity * 0.3;

              // Apply to transforms
              const useEl1 = document.getElementById("shapeUse");
              const useEl2 = document.getElementById("shapeUse2");

              if (useEl1) {
                const tx = params.positionX1 + offsetX1;
                const ty = params.positionY1 + offsetY1;
                const s = params.scale1;
                const r = params.rotation1 + rotation1;
                const skx = params.skewX1 + skewXOffset1;
                const sky = params.skewY1 + skewYOffset1;
                const transform = `translate(${tx}, ${ty}) skewX(${skx}) skewY(${sky}) rotate(${r}) scale(${s})`;
                useEl1.setAttribute("transform", transform);
              }

              if (useEl2) {
                const tx = params.positionX2 + offsetX2;
                const ty = params.positionY2 + offsetY2;
                const s = params.scale2;
                const r = params.rotation2 + rotation2;
                const skx = params.skewX2 + skewXOffset2;
                const sky = params.skewY2 + skewYOffset2;
                const transform = `translate(${tx}, ${ty}) skewX(${skx}) skewY(${sky}) rotate(${r}) scale(${s})`;
                useEl2.setAttribute("transform", transform);
              }

              animationId = requestAnimationFrame(animate);
            }
            animate();
          } else {
            // Reset to base transforms when animation stops
            updateTransform1();
            updateTransform2();
          }
        }

        function updateAnimation() {
          startAnimation();
        }

        const af = gui.addFolder("Animation");
        af.add(params, "animate").name("Enable Animation").onChange(updateAnimation);
        af.add(params, "animationSpeed", 0, 5, 0.1)
          .name("Speed")
          .onChange(() => {
            if (params.animate) {
              // Animation will update automatically
            }
          });
        af.add(params, "animationIntensity", 0, 20, 0.1)
          .name("Strength")
          .onChange(() => {
            if (params.animate) {
              // Animation will update automatically
            }
          });
        af.add(params, "animationRandomness", 0, 5, 0.1)
          .name("Randomness")
          .onChange(() => {
            if (params.animate) {
              // Animation will update automatically
            }
          });

        const blf = gui.addFolder("Blend Modes");
        blf
          .add(params, "blendMode1", [
            "normal",
            "multiply",
            "screen",
            "overlay",
            "soft-light",
            "hard-light",
            "color-dodge",
            "color-burn",
            "darken",
            "lighten",
            "difference",
            "exclusion",
            "hue",
            "saturation",
            "color",
            "luminosity",
          ])
          .name("Shape 1 Blend")
          .onChange(updateBlendModes);
        blf
          .add(params, "blendMode2", [
            "normal",
            "multiply",
            "screen",
            "overlay",
            "soft-light",
            "hard-light",
            "color-dodge",
            "color-burn",
            "darken",
            "lighten",
            "difference",
            "exclusion",
            "hue",
            "saturation",
            "color",
            "luminosity",
          ])
          .name("Shape 2 Blend")
          .onChange(updateBlendModes);

        const gf = gui.addFolder("Grain Overlay");
        gf.add(params, "grainOpacity", 0, 1, 0.01).name("Grain Opacity").onChange(updateGrain);
        gf.add(params, "grainScale", 0.1, 5, 0.1).name("Grain Scale").onChange(updateGrain);
        gf.add(params, "grainPositionX", -1500, 1500, 1).name("Grain Position X").onChange(updateGrain);
        gf.add(params, "grainPositionY", -1200, 1200, 1).name("Grain Position Y").onChange(updateGrain);
        gf.add(params, "grainBlend", [
          "normal",
          "multiply",
          "screen",
          "overlay",
          "soft-light",
          "hard-light",
          "color-dodge",
          "color-burn",
          "darken",
          "lighten",
          "difference",
          "exclusion",
        ])
          .name("Grain Blend Mode")
          .onChange(updateGrain);

        const ff = gui.addFolder("Edge Feather");
        ff.add(params, "feather", 0, 150, 1).name("Feather Amount").onChange(updateFeather);

        const vf = gui.addFolder("Visual Effects");
        vf.add(params, "brightness", 0, 3, 0.01).name("Brightness").onChange(updateEffects);
        vf.add(params, "contrast", 0, 3, 0.01).name("Contrast").onChange(updateEffects);

        const df = gui.addFolder("Displacement");
        df.add(params, "displacementStrength", 0, 1000, 5).name("Strength").onChange(updateDisplacement);
        df.add(params, "displacementFrequency", 0.005, 0.05, 0.001).name("Frequency (lower = smoother)").onChange(updateDisplacement);
        df.add(params, "displacementOctaves", 1, 8, 1).name("Octaves").onChange(updateDisplacement);
        df.add(params, "displacementAnimated").name("Lava Lamp (animated)").onChange(updateDisplacement);
        df.add(params, "displacementSpeed", 0.001, 0.02, 0.001).name("Animation Speed").onChange(updateDisplacement);

        const pathf = gui.addFolder("Shape Path");
        const pathController = pathf.add(params, "pathData").name("Shape 1 Path").onChange(updatePath);
        pathf.add({ update: () => updatePath() }, "update").name("Update Shape 1");
        const pathController2 = pathf.add(params, "pathData2").name("Shape 2 Path").onChange(updatePath2);
        pathf.add({ update: () => updatePath2() }, "update").name("Update Shape 2");

        // Store initial paths on load
        params.pathData = document.getElementById("shapePath")?.getAttribute("d") || params.pathData;
        params.pathData2 = document.getElementById("shapePath2")?.getAttribute("d") || params.pathData2;

        // Position GUI on the left
        setTimeout(() => {
          gui.domElement.style.position = "fixed";
          gui.domElement.style.top = "20px";
          gui.domElement.style.left = "20px";
          gui.domElement.style.zIndex = "1000";
        }, 100);

        // Preset management
        const PRESET_STORAGE_KEY = "glowsGradientPresets";
        const LAST_PRESET_KEY = "glowsGradientLastPreset";

        function savePresets() {
          try {
            const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY) || "{}");
            return presets;
          } catch (e) {
            return {};
          }
        }

        function savePresetToStorage(presets) {
          try {
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
          } catch (e) {
            console.error("Failed to save preset:", e);
            alert("Failed to save preset. LocalStorage may be disabled or full.");
          }
        }

        function loadPreset(presetName) {
          const presets = savePresets();
          if (!presets[presetName]) {
            alert(`Preset "${presetName}" not found.`);
            return;
          }

          const preset = presets[presetName];

          // Restore all parameters
          Object.keys(params).forEach((key) => {
            if (preset[key] !== undefined) {
              params[key] = preset[key];
            }
          });

          // Update all visual elements
          updateTables1();
          updateTables2();
          updateBlur();
          updateTransform1();
          updateTransform2();
          updateFeather();
          updateEffects();
          updateDisplacement();
          updatePath();
          updatePath2();
          updateBlobBlur();
          updateBlendModes();
          updateGrain();
          updateAnimation();

          // Refresh GUI controllers
          gui.updateDisplay();

          // Save as last used preset
          localStorage.setItem(LAST_PRESET_KEY, presetName);

          console.log(`Loaded preset: ${presetName}`);
        }

        function savePreset(presetName) {
          if (!presetName || presetName.trim() === "") {
            alert("Please enter a preset name.");
            return;
          }

          const presets = savePresets();

          // Create a deep copy of current params
          const presetData = {};
          Object.keys(params).forEach((key) => {
            presetData[key] = params[key];
          });

          presets[presetName.trim()] = presetData;
          savePresetToStorage(presets);

          // Refresh preset list in GUI
          refreshPresetGUI();

          // Save as last used preset
          localStorage.setItem(LAST_PRESET_KEY, presetName.trim());

          console.log(`Saved preset: ${presetName}`);
        }

        function deletePreset(presetName) {
          if (!confirm(`Delete preset "${presetName}"?`)) {
            return;
          }

          const presets = savePresets();
          delete presets[presetName];
          savePresetToStorage(presets);

          // Refresh preset list in GUI
          refreshPresetGUI();

          console.log(`Deleted preset: ${presetName}`);
        }

        let presetFolder = null;
        let presetControllers = [];

        function refreshPresetGUI() {
          // Remove existing preset controllers
          presetControllers.forEach((ctrl) => {
            try {
              ctrl.destroy();
            } catch (e) {
              // Controller might already be destroyed
            }
          });
          presetControllers = [];

          const presets = savePresets();
          const presetNames = Object.keys(presets).sort();

          if (presetNames.length === 0) {
            // No presets yet
            if (presetFolder) {
              presetFolder.children.forEach((child) => {
                if (child.$name && child.$name.includes("Preset:")) {
                  try {
                    child.destroy();
                  } catch (e) {}
                }
              });
            }
            return;
          }

          // Add buttons for each preset
          presetNames.forEach((presetName) => {
            const presetObj = {
              load: () => loadPreset(presetName),
            };

            const loadCtrl = presetFolder.add(presetObj, "load").name(`📁 ${presetName}`);
            presetControllers.push(loadCtrl);

            // Add delete button as a separate object
            const deleteObj = {
              delete: () => deletePreset(presetName),
            };
            const deleteCtrl = presetFolder.add(deleteObj, "delete").name(`🗑️ ${presetName}`);
            presetControllers.push(deleteCtrl);
          });
        }

        // Create preset management folder
        presetFolder = gui.addFolder("Presets");
        presetFolder.open(); // Open by default so user can see "Save Current"

        const savePresetObj = {
          name: "",
          save: () => {
            if (savePresetObj.name.trim()) {
              savePreset(savePresetObj.name);
              savePresetObj.name = ""; // Clear input
              gui.updateDisplay();
            }
          },
        };

        presetFolder.add(savePresetObj, "name").name("New Preset Name");
        presetFolder.add(savePresetObj, "save").name("💾 Save Current");

        // Load last used preset on page load
        const lastPresetName = localStorage.getItem(LAST_PRESET_KEY);
        if (lastPresetName) {
          const presets = savePresets();
          if (presets[lastPresetName]) {
            // Small delay to ensure GUI is ready
            setTimeout(() => {
              loadPreset(lastPresetName);
            }, 100);
          }
        }

        // Initialize preset list
        refreshPresetGUI();

        updateTables1();
        updateTables2();
        updateBlur();
        updateTransform1();
        updateTransform2();
        updateFeather();
        updateEffects();
        updateDisplacement();
        updatePath2();
        updateBlobBlur();
        updateBlendModes();
        updateGrain();
      </script>
    </div>
  </body>
</html>
