<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>Flowing Blob Gradient</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: #0f0f0f;
      }
      .stage {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        overflow: hidden;
        background-image: url("cozy - 1291.jpg");
        background-size: cover;
        background-position: center top;
        background-repeat: no-repeat;
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      #blobCanvas {
        z-index: 1;
      }

      #blobCanvas2 {
        z-index: 2;
      }

      #grainOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 3;
        pointer-events: none;
        opacity: 0;
        background-image: url("grain2.jpeg");
        background-size: 200px 200px;
        background-repeat: repeat;
        mix-blend-mode: overlay;
      }
    </style>
  </head>
  <body>
    <div class="stage">
      <canvas id="blobCanvas"></canvas>
      <canvas id="blobCanvas2"></canvas>
      <div id="grainOverlay"></div>
      <script type="module">
        import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.21/+esm";

        const canvas = document.getElementById("blobCanvas");
        const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");

        if (!gl) {
          alert("WebGL not supported. Please use a modern browser.");
          throw new Error("WebGL not supported");
        }

        // Simplex noise implementation
        // Based on: https://github.com/ashima/webgl-noise
        const simplexNoiseSource = `
          //
          // Description : Array and textureless GLSL 2D/3D/4D simplex 
          //               noise functions.
          //      Author : Ian McEwan, Ashima Arts.
          //  Maintainer : stegu
          //     Lastmod : 20110822 (ijm)
          //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
          //               Distributed under the MIT License. See LICENSE file.
          //               https://github.com/ashima/webgl-noise
          //

          vec3 mod289(vec3 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 mod289(vec4 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
          }

          vec4 permute(vec4 x) {
              return mod289(((x*34.0)+1.0)*x);
          }

          vec4 taylorInvSqrt(vec4 r)
          {
            return 1.79284291400159 - 0.85373472095314 * r;
          }

          float snoise(vec3 v)
            { 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

          // First corner
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;

          // Other corners
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );

            //   x0 = x0 - 0.0 + 0.0 * C.xxx;
            //   x1 = x0 - i1  + 1.0 * C.xxx;
            //   x2 = x0 - i2  + 2.0 * C.xxx;
            //   x3 = x0 - 1.0 + 3.0 * C.xxx;
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

          // Permutations
            i = mod289(i); 
            vec4 p = permute( permute( permute( 
                       i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

          // Gradients: 7x7 points over a square, mapped onto an octahedron.
          // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
            float n_ = 0.142857142857; // 1.0/7.0
            vec3  ns = n_ * D.wyz - D.xzx;

            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);

            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );

            //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
            //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));

            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);

          //Normalise gradients
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;

          // Mix final noise value
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                          dot(p2,x2), dot(p3,x3) ) );
          }

          // 2D simplex noise (using 3D with z=0)
          float snoise2D(vec2 v) {
            return snoise(vec3(v, 0.0));
          }
        `;

        const vertexShaderSource = `#version 300 es
          in vec2 a_position;
          
          void main() {
            gl_Position = vec4(a_position, 0, 1);
          }
        `;

        const fragmentShaderSource = `#version 300 es
          precision highp float;
          
          out vec4 outColor;
          
          uniform vec2 u_resolution;
          uniform float u_time;
          uniform vec2 u_center;
          uniform float u_scale;
          uniform float u_blur;
          uniform float u_feather;
          uniform float u_flowSpeed;
          uniform float u_flowAmount;
          uniform float u_noiseScale;
          uniform float u_waveHeight;
          uniform vec2 u_position;
          uniform vec3 u_colorStop1;
          uniform vec3 u_colorStop2;
          uniform vec3 u_colorStop3;
          uniform vec3 u_colorStop4;
          uniform vec3 u_colorStop5;
          uniform float u_stopPos1;
          uniform float u_stopPos2;
          uniform float u_stopPos3;
          uniform float u_stopPos4;
          uniform float u_stopPos5;
          
          ${simplexNoiseSource}
          
          // Stacked noise for blob boundary - Layer 1 (larger, smoother waves)
          float blobNoise(vec2 p, float time) {
            const float L = 0.0018;
            const float S = 0.04;
            const float F = 0.043;
            
            float noise = 0.0;
            noise += snoise2D(p * (L / 1.00) + vec2(F * time, 0.0)) * 0.85;
            noise += snoise2D(p * (L / 1.30) + vec2(F * time * 1.26, time * S * 1.26)) * 1.15;
            noise += snoise2D(p * (L / 1.86) + vec2(F * time * 1.09, time * S * 1.09)) * 0.60;
            noise += snoise2D(p * (L / 3.25) + vec2(F * time * 0.89, time * S * 0.89)) * 0.40;
            
            return noise;
          }

          // Stacked noise for blob boundary - Layer 2 (different pattern, more organic)
          float blobNoise2(vec2 p, float time) {
            const float L = 0.0022;  // Slightly different base frequency
            const float S = 0.05;    // Different speed
            const float F = 0.038;   // Different flow amount
            
            float noise = 0.0;
            // Different wave combinations for distinct shape
            noise += snoise2D(p * (L / 1.15) + vec2(-F * time * 0.8, time * S * 0.9)) * 1.0;  // Reversed flow
            noise += snoise2D(p * (L / 1.50) + vec2(F * time * 1.4, -time * S * 1.1)) * 0.90; // Opposing direction
            noise += snoise2D(p * (L / 2.10) + vec2(F * time * 0.7, time * S * 1.3)) * 0.70;
            noise += snoise2D(p * (L / 3.80) + vec2(-F * time * 1.2, time * S * 0.8)) * 0.50;
            noise += snoise2D(p * (L / 5.50) + vec2(F * time * 0.6, -time * S * 1.5)) * 0.35; // Extra layer for more detail
            
            return noise;
          }
          
          // Background noise for color mapping
          float backgroundNoise(vec2 p, float time, float offset) {
            const float L = 0.0015;
            const float S = 0.13;
            const float Y_SCALE = 3.0;
            const float F = 0.11;
            
            float t = time + offset;
            float x = p.x * L;
            float y = p.y * L * Y_SCALE;
            
            float noise = 0.5;
            noise += snoise(vec3(x * 1.0 + F * t, y * 1.00, t * S)) * 0.30;
            noise += snoise(vec3(x * 0.6 + F * t * 0.6, y * 0.85, t * S)) * 0.26;
            noise += snoise(vec3(x * 0.4 + F * t * 0.8, y * 0.70, t * S)) * 0.22;
            
            return clamp(noise, 0.0, 1.0);
          }
          
          // Smoothstep variant (quintic)
          float smoothstep5(float t) {
            return t * t * t * (t * (6.0 * t - 15.0) + 10.0);
          }
          
          // Color gradient mapping with customizable stops
          vec3 gradientColor(float t) {
            vec3 color = u_colorStop1;
            
            // Interpolate between color stops based on their positions
            if (t <= u_stopPos1) {
              return u_colorStop1;
            } else if (t <= u_stopPos2) {
              float range = u_stopPos2 - u_stopPos1;
              float localT = range > 0.0 ? (t - u_stopPos1) / range : 0.0;
              return mix(u_colorStop1, u_colorStop2, localT);
            } else if (t <= u_stopPos3) {
              float range = u_stopPos3 - u_stopPos2;
              float localT = range > 0.0 ? (t - u_stopPos2) / range : 0.0;
              return mix(u_colorStop2, u_colorStop3, localT);
            } else if (t <= u_stopPos4) {
              float range = u_stopPos4 - u_stopPos3;
              float localT = range > 0.0 ? (t - u_stopPos3) / range : 0.0;
              return mix(u_colorStop3, u_colorStop4, localT);
            } else if (t <= u_stopPos5) {
              float range = u_stopPos5 - u_stopPos4;
              float localT = range > 0.0 ? (t - u_stopPos4) / range : 0.0;
              return mix(u_colorStop4, u_colorStop5, localT);
            } else {
              return u_colorStop5;
            }
          }
          
          void main() {
            vec2 uv = gl_FragCoord.xy;
            // Apply position offset
            vec2 centeredP = uv - u_center - u_position;
            vec2 p = centeredP / u_scale;
            
            // Calculate distance from center
            float dist = length(p);
            
            // Base blob radius
            float baseRadius = 300.0;
            
            // Add noise-based wave displacement
            float noise = blobNoise(p * u_noiseScale, u_time * u_flowSpeed);
            float waveDisplacement = noise * u_waveHeight;
            
            // Calculate blob boundary
            // blobDist < 0 means inside blob, > 0 means outside
            float blobDist = dist - (baseRadius + waveDisplacement);
            
            // Calculate alpha: 1.0 inside blob, 0.0 outside
            // Main blur for overall shape
            float alpha = smoothstep(u_blur, -u_blur, blobDist);
            
            // Apply feather for additional edge softness
            if (u_feather > 0.0) {
              float featherAlpha = smoothstep(u_feather, -u_feather, blobDist);
              alpha = min(alpha, featherAlpha);
            }
            
            // Apply smoothstep5 for smoother edges
            alpha = smoothstep5(clamp(alpha, 0.0, 1.0));
            
            // Calculate gradient color based on noise
            // This creates the flowing, animated gradient
            vec2 flowOffset = vec2(u_time * u_flowAmount * 10.0, 0.0);
            float noiseValue = backgroundNoise(p * 0.5 + flowOffset, u_time, 0.0);
            vec3 color = gradientColor(noiseValue);
            
            // Apply alpha to mask the gradient to the blob shape
            // Areas outside the blob will have alpha = 0 (transparent)
            // Color stays at full brightness, alpha controls transparency
            outColor = vec4(color, alpha);
          }
        `;

        // Helper functions
        function createShader(gl, type, source) {
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Shader compilation error:", gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
          }
          return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
          const program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);

          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error("Program linking error:", gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
          }
          return program;
        }

        // Initialize WebGL for first canvas
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        if (!program) {
          throw new Error("Failed to create WebGL program");
        }

        // Initialize WebGL for second canvas
        const canvas2 = document.getElementById("blobCanvas2");
        const gl2 = canvas2.getContext("webgl2") || canvas2.getContext("webgl");

        if (!gl2) {
          throw new Error("WebGL not supported for second canvas");
        }

        // Create separate fragment shader for layer 2 that uses blobNoise2
        const fragmentShaderSource2 = `#version 300 es
          precision highp float;
          
          out vec4 outColor;
          
          uniform vec2 u_resolution;
          uniform float u_time;
          uniform vec2 u_center;
          uniform float u_scale;
          uniform float u_blur;
          uniform float u_feather;
          uniform float u_flowSpeed;
          uniform float u_flowAmount;
          uniform float u_noiseScale;
          uniform float u_waveHeight;
          uniform vec2 u_position;
          uniform vec3 u_colorStop1;
          uniform vec3 u_colorStop2;
          uniform vec3 u_colorStop3;
          uniform vec3 u_colorStop4;
          uniform vec3 u_colorStop5;
          uniform float u_stopPos1;
          uniform float u_stopPos2;
          uniform float u_stopPos3;
          uniform float u_stopPos4;
          uniform float u_stopPos5;
          
          ${simplexNoiseSource}
          
          // Stacked noise for blob boundary - Layer 1 (larger, smoother waves)
          float blobNoise(vec2 p, float time) {
            const float L = 0.0018;
            const float S = 0.04;
            const float F = 0.043;
            
            float noise = 0.0;
            noise += snoise2D(p * (L / 1.00) + vec2(F * time, 0.0)) * 0.85;
            noise += snoise2D(p * (L / 1.30) + vec2(F * time * 1.26, time * S * 1.26)) * 1.15;
            noise += snoise2D(p * (L / 1.86) + vec2(F * time * 1.09, time * S * 1.09)) * 0.60;
            noise += snoise2D(p * (L / 3.25) + vec2(F * time * 0.89, time * S * 0.89)) * 0.40;
            
            return noise;
          }

          // Stacked noise for blob boundary - Layer 2 (different pattern, more organic)
          float blobNoise2(vec2 p, float time) {
            const float L = 0.0022;  // Slightly different base frequency
            const float S = 0.05;    // Different speed
            const float F = 0.038;   // Different flow amount
            
            float noise = 0.0;
            // Different wave combinations for distinct shape
            noise += snoise2D(p * (L / 1.15) + vec2(-F * time * 0.8, time * S * 0.9)) * 1.0;  // Reversed flow
            noise += snoise2D(p * (L / 1.50) + vec2(F * time * 1.4, -time * S * 1.1)) * 0.90; // Opposing direction
            noise += snoise2D(p * (L / 2.10) + vec2(F * time * 0.7, time * S * 1.3)) * 0.70;
            noise += snoise2D(p * (L / 3.80) + vec2(-F * time * 1.2, time * S * 0.8)) * 0.50;
            noise += snoise2D(p * (L / 5.50) + vec2(F * time * 0.6, -time * S * 1.5)) * 0.35; // Extra layer for more detail
            
            return noise;
          }
          
          // Background noise for color mapping
          float backgroundNoise(vec2 p, float time, float offset) {
            const float L = 0.0015;
            const float S = 0.13;
            const float Y_SCALE = 3.0;
            const float F = 0.11;
            
            float t = time + offset;
            float x = p.x * L;
            float y = p.y * L * Y_SCALE;
            
            float noise = 0.5;
            noise += snoise(vec3(x * 1.0 + F * t, y * 1.00, t * S)) * 0.30;
            noise += snoise(vec3(x * 0.6 + F * t * 0.6, y * 0.85, t * S)) * 0.26;
            noise += snoise(vec3(x * 0.4 + F * t * 0.8, y * 0.70, t * S)) * 0.22;
            
            return clamp(noise, 0.0, 1.0);
          }
          
          // Smoothstep variant (quintic)
          float smoothstep5(float t) {
            return t * t * t * (t * (6.0 * t - 15.0) + 10.0);
          }
          
          // Color gradient mapping with customizable stops
          vec3 gradientColor(float t) {
            vec3 color = u_colorStop1;
            
            // Interpolate between color stops based on their positions
            if (t <= u_stopPos1) {
              return u_colorStop1;
            } else if (t <= u_stopPos2) {
              float range = u_stopPos2 - u_stopPos1;
              float localT = range > 0.0 ? (t - u_stopPos1) / range : 0.0;
              return mix(u_colorStop1, u_colorStop2, localT);
            } else if (t <= u_stopPos3) {
              float range = u_stopPos3 - u_stopPos2;
              float localT = range > 0.0 ? (t - u_stopPos2) / range : 0.0;
              return mix(u_colorStop2, u_colorStop3, localT);
            } else if (t <= u_stopPos4) {
              float range = u_stopPos4 - u_stopPos3;
              float localT = range > 0.0 ? (t - u_stopPos3) / range : 0.0;
              return mix(u_colorStop3, u_colorStop4, localT);
            } else if (t <= u_stopPos5) {
              float range = u_stopPos5 - u_stopPos4;
              float localT = range > 0.0 ? (t - u_stopPos4) / range : 0.0;
              return mix(u_colorStop4, u_colorStop5, localT);
            } else {
              return u_colorStop5;
            }
          }
          
          void main() {
            vec2 uv = gl_FragCoord.xy;
            // Apply position offset
            vec2 centeredP = uv - u_center - u_position;
            vec2 p = centeredP / u_scale;
            
            // Calculate distance from center
            float dist = length(p);
            
            // Base blob radius - similar size to layer 1
            float baseRadius = 300.0;
            
            // Add noise-based wave displacement - use blobNoise2 for different organic shape
            float noise = blobNoise2(p * u_noiseScale, u_time * u_flowSpeed);
            float waveDisplacement = noise * u_waveHeight;
            
            // Calculate blob boundary
            // blobDist < 0 means inside blob, > 0 means outside
            float blobDist = dist - (baseRadius + waveDisplacement);
            
            // Calculate alpha: 1.0 inside blob, 0.0 outside
            // Main blur for overall shape
            float alpha = smoothstep(u_blur, -u_blur, blobDist);
            
            // Apply feather for additional edge softness
            if (u_feather > 0.0) {
              float featherAlpha = smoothstep(u_feather, -u_feather, blobDist);
              alpha = min(alpha, featherAlpha);
            }
            
            // Apply smoothstep5 for smoother edges
            alpha = smoothstep5(clamp(alpha, 0.0, 1.0));
            
            // Calculate gradient color based on noise
            // This creates the flowing, animated gradient
            vec2 flowOffset = vec2(u_time * u_flowAmount * 10.0, 0.0);
            float noiseValue = backgroundNoise(p * 0.5 + flowOffset, u_time, 0.0);
            vec3 color = gradientColor(noiseValue);
            
            // Apply alpha to mask the gradient to the blob shape
            // Areas outside the blob will have alpha = 0 (transparent)
            // Color stays at full brightness, alpha controls transparency
            outColor = vec4(color, alpha);
          }
        `;

        const vertexShader2 = createShader(gl2, gl2.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader2 = createShader(gl2, gl2.FRAGMENT_SHADER, fragmentShaderSource2);
        const program2 = createProgram(gl2, vertexShader2, fragmentShader2);

        if (!program2) {
          throw new Error("Failed to create WebGL program for second canvas");
        }

        // Create full-screen quads for both canvases
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

        const positionBuffer2 = gl2.createBuffer();
        gl2.bindBuffer(gl2.ARRAY_BUFFER, positionBuffer2);
        gl2.bufferData(gl2.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl2.STATIC_DRAW);

        // Get locations
        const positionLocation = gl.getAttribLocation(program, "a_position");
        const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
        const timeLocation = gl.getUniformLocation(program, "u_time");
        const centerLocation = gl.getUniformLocation(program, "u_center");
        const scaleLocation = gl.getUniformLocation(program, "u_scale");
        const blurLocation = gl.getUniformLocation(program, "u_blur");
        const featherLocation = gl.getUniformLocation(program, "u_feather");
        const flowSpeedLocation = gl.getUniformLocation(program, "u_flowSpeed");
        const flowAmountLocation = gl.getUniformLocation(program, "u_flowAmount");
        const noiseScaleLocation = gl.getUniformLocation(program, "u_noiseScale");
        const waveHeightLocation = gl.getUniformLocation(program, "u_waveHeight");
        const positionLocation_uniform = gl.getUniformLocation(program, "u_position");
        const colorStop1Location = gl.getUniformLocation(program, "u_colorStop1");
        const colorStop2Location = gl.getUniformLocation(program, "u_colorStop2");
        const colorStop3Location = gl.getUniformLocation(program, "u_colorStop3");
        const colorStop4Location = gl.getUniformLocation(program, "u_colorStop4");
        const colorStop5Location = gl.getUniformLocation(program, "u_colorStop5");
        const stopPos1Location = gl.getUniformLocation(program, "u_stopPos1");
        const stopPos2Location = gl.getUniformLocation(program, "u_stopPos2");
        const stopPos3Location = gl.getUniformLocation(program, "u_stopPos3");
        const stopPos4Location = gl.getUniformLocation(program, "u_stopPos4");
        const stopPos5Location = gl.getUniformLocation(program, "u_stopPos5");

        // Get locations for layer 2
        const positionLocation2 = gl2.getAttribLocation(program2, "a_position");
        const resolutionLocation2 = gl2.getUniformLocation(program2, "u_resolution");
        const timeLocation2 = gl2.getUniformLocation(program2, "u_time");
        const centerLocation2 = gl2.getUniformLocation(program2, "u_center");
        const scaleLocation2 = gl2.getUniformLocation(program2, "u_scale");
        const blurLocation2 = gl2.getUniformLocation(program2, "u_blur");
        const featherLocation2 = gl2.getUniformLocation(program2, "u_feather");
        const flowSpeedLocation2 = gl2.getUniformLocation(program2, "u_flowSpeed");
        const flowAmountLocation2 = gl2.getUniformLocation(program2, "u_flowAmount");
        const noiseScaleLocation2 = gl2.getUniformLocation(program2, "u_noiseScale");
        const waveHeightLocation2 = gl2.getUniformLocation(program2, "u_waveHeight");
        const positionLocation_uniform2 = gl2.getUniformLocation(program2, "u_position");
        const colorStop1Location2 = gl2.getUniformLocation(program2, "u_colorStop1");
        const colorStop2Location2 = gl2.getUniformLocation(program2, "u_colorStop2");
        const colorStop3Location2 = gl2.getUniformLocation(program2, "u_colorStop3");
        const colorStop4Location2 = gl2.getUniformLocation(program2, "u_colorStop4");
        const colorStop5Location2 = gl2.getUniformLocation(program2, "u_colorStop5");
        const stopPos1Location2 = gl2.getUniformLocation(program2, "u_stopPos1");
        const stopPos2Location2 = gl2.getUniformLocation(program2, "u_stopPos2");
        const stopPos3Location2 = gl2.getUniformLocation(program2, "u_stopPos3");
        const stopPos4Location2 = gl2.getUniformLocation(program2, "u_stopPos4");
        const stopPos5Location2 = gl2.getUniformLocation(program2, "u_stopPos5");

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255] : [1, 1, 1];
        }

        // Parameters for layer 1
        const params = {
          // Gradient colors - based on the image (yellow → sky blue → orange → reddish-orange)
          colorStop1: "#FFF8A0", // Bright, soft yellow (top-right)
          colorStop2: "#87CEEB", // Sky blue
          colorStop3: "#FF8C42", // Warm, rich orange
          colorStop4: "#FF6B35", // Deeper reddish-orange
          colorStop5: "#D44226", // Deep red-orange
          stopPos1: 0.0,
          stopPos2: 0.3,
          stopPos3: 0.6,
          stopPos4: 0.85,
          stopPos5: 1.0,
          // Position - top right corner
          positionX: 400,
          positionY: 400,
          // Blob settings
          scale: 1.0,
          blur: 80.0,
          feather: 40.0,
          flowSpeed: 0.1,
          flowAmount: 0.5,
          noiseScale: 1.0,
          waveHeight: 50.0,
        };

        // Parameters for layer 2
        const params2 = {
          // Gradient colors - complementary sky and warm tones
          colorStop1: "#FFE066", // Soft yellow-gold
          colorStop2: "#70B8D8", // Lighter sky blue
          colorStop3: "#FFA366", // Medium orange
          colorStop4: "#FF7F4D", // Orange-red
          colorStop5: "#E05A3A", // Deep orange-red
          stopPos1: 0.0,
          stopPos2: 0.25,
          stopPos3: 0.55,
          stopPos4: 0.8,
          stopPos5: 1.0,
          // Position - slightly offset for layered effect
          positionX: 450,
          positionY: 450,
          // Blob settings
          scale: 1.0,
          blur: 80.0,
          feather: 40.0,
          flowSpeed: 0.1,
          flowAmount: 0.5,
          noiseScale: 1.0,
          waveHeight: 50.0,
        };

        // Blending mode
        const blendModes = [
          "normal",
          "multiply",
          "screen",
          "overlay",
          "soft-light",
          "hard-light",
          "color-dodge",
          "color-burn",
          "darken",
          "lighten",
          "difference",
          "exclusion",
        ];
        params.blendMode = "normal";
        params.globalBlur = 0.0; // Global blur on top of shader
        params.grainOpacity = 0.0;
        params.grainScale = 1.0;
        params.grainBlend = "overlay";

        // Preset management
        const PRESET_STORAGE_KEY = "glowsGradient9Presets";
        const LAST_PRESET_KEY = "glowsGradient9LastPreset";

        function savePresets() {
          try {
            const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY) || "{}");
            return presets;
          } catch (e) {
            return {};
          }
        }

        function savePresetToStorage(presets) {
          try {
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
          } catch (e) {
            console.error("Failed to save preset:", e);
            alert("Failed to save preset. LocalStorage may be disabled or full.");
          }
        }

        let presetFolder = null;
        let presetControllers = [];

        function loadPreset(presetName) {
          const presets = savePresets();
          if (!presets[presetName]) {
            alert(`Preset "${presetName}" not found.`);
            return;
          }

          const preset = presets[presetName];

          // Restore layer 1 parameters
          if (preset.params) {
            Object.keys(params).forEach((key) => {
              if (preset.params[key] !== undefined) {
                params[key] = preset.params[key];
              }
            });
          }

          // Restore layer 2 parameters
          if (preset.params2) {
            Object.keys(params2).forEach((key) => {
              if (preset.params2[key] !== undefined) {
                params2[key] = preset.params2[key];
              }
            });
          }

          // Update blend mode and blur
          if (preset.blendMode !== undefined) {
            params.blendMode = preset.blendMode;
            canvas2.style.mixBlendMode = params.blendMode;
          }
          if (preset.globalBlur !== undefined) {
            params.globalBlur = preset.globalBlur;
            updateGlobalBlur();
          }

          // Refresh GUI controllers
          gui.updateDisplay();

          // Save as last used preset
          localStorage.setItem(LAST_PRESET_KEY, presetName);

          console.log(`Loaded preset: ${presetName}`);
        }

        function savePreset(presetName) {
          if (!presetName || presetName.trim() === "") {
            alert("Please enter a preset name.");
            return;
          }

          const presets = savePresets();

          // Create a deep copy of current params
          const presetData = {
            params: {},
            params2: {},
            blendMode: params.blendMode,
            globalBlur: params.globalBlur,
          };

          Object.keys(params).forEach((key) => {
            presetData.params[key] = params[key];
          });

          Object.keys(params2).forEach((key) => {
            presetData.params2[key] = params2[key];
          });

          presets[presetName.trim()] = presetData;
          savePresetToStorage(presets);

          // Refresh preset list in GUI
          refreshPresetGUI();

          // Save as last used preset
          localStorage.setItem(LAST_PRESET_KEY, presetName.trim());

          console.log(`Saved preset: ${presetName}`);
        }

        function deletePreset(presetName) {
          if (!confirm(`Delete preset "${presetName}"?`)) {
            return;
          }

          const presets = savePresets();
          delete presets[presetName];
          savePresetToStorage(presets);

          // Refresh preset list in GUI
          refreshPresetGUI();

          console.log(`Deleted preset: ${presetName}`);
        }

        function refreshPresetGUI() {
          // Remove existing preset controllers
          presetControllers.forEach((ctrl) => {
            try {
              ctrl.destroy();
            } catch (e) {
              // Controller might already be destroyed
            }
          });
          presetControllers = [];

          const presets = savePresets();
          const presetNames = Object.keys(presets).sort();

          if (presetNames.length === 0) {
            return;
          }

          // Add buttons for each preset
          presetNames.forEach((presetName) => {
            const presetObj = {
              load: () => loadPreset(presetName),
            };

            const loadCtrl = presetFolder.add(presetObj, "load").name(`📁 ${presetName}`);
            presetControllers.push(loadCtrl);

            // Add delete button as a separate object
            const deleteObj = {
              delete: () => deletePreset(presetName),
            };
            const deleteCtrl = presetFolder.add(deleteObj, "delete").name(`🗑️ ${presetName}`);
            presetControllers.push(deleteCtrl);
          });
        }

        // GUI
        const gui = new GUI();

        // Create preset management folder FIRST so it appears at the top
        presetFolder = gui.addFolder("Presets");
        presetFolder.open(); // Open by default so user can see "Save Current"

        const savePresetObj = {
          name: "",
          save: () => {
            if (savePresetObj.name.trim()) {
              savePreset(savePresetObj.name);
              savePresetObj.name = ""; // Clear input
              gui.updateDisplay();
            }
          },
        };

        presetFolder.add(savePresetObj, "name").name("New Preset Name");
        presetFolder.add(savePresetObj, "save").name("💾 Save Current");

        // Layer 1 folder
        const layer1Folder = gui.addFolder("Layer 1");
        const gradientFolder1 = layer1Folder.addFolder("Gradient Colors");
        gradientFolder1.addColor(params, "colorStop1").name("Stop 1");
        gradientFolder1.addColor(params, "colorStop2").name("Stop 2");
        gradientFolder1.addColor(params, "colorStop3").name("Stop 3");
        gradientFolder1.addColor(params, "colorStop4").name("Stop 4");
        gradientFolder1.addColor(params, "colorStop5").name("Stop 5");

        const stopPosFolder1 = layer1Folder.addFolder("Color Stop Positions");
        stopPosFolder1.add(params, "stopPos1", 0, 1, 0.01).name("Stop 1 Position");
        stopPosFolder1.add(params, "stopPos2", 0, 1, 0.01).name("Stop 2 Position");
        stopPosFolder1.add(params, "stopPos3", 0, 1, 0.01).name("Stop 3 Position");
        stopPosFolder1.add(params, "stopPos4", 0, 1, 0.01).name("Stop 4 Position");
        stopPosFolder1.add(params, "stopPos5", 0, 1, 0.01).name("Stop 5 Position");

        const positionFolder1 = layer1Folder.addFolder("Position");
        positionFolder1.add(params, "positionX", -1000, 1000, 1).name("Position X");
        positionFolder1.add(params, "positionY", -1000, 1000, 1).name("Position Y");

        layer1Folder.add(params, "scale", 0.5, 2.0, 0.01).name("Scale");
        layer1Folder.add(params, "blur", 0, 200, 1).name("Blur");
        layer1Folder.add(params, "feather", 0, 150, 1).name("Feather");
        layer1Folder.add(params, "flowSpeed", 0, 1, 0.01).name("Flow Speed");
        layer1Folder.add(params, "flowAmount", 0, 2, 0.01).name("Flow Amount");
        layer1Folder.add(params, "noiseScale", 0.1, 3.0, 0.1).name("Noise Scale");
        layer1Folder.add(params, "waveHeight", 0, 150, 1).name("Wave Height");

        // Layer 2 folder
        const layer2Folder = gui.addFolder("Layer 2");
        const gradientFolder2 = layer2Folder.addFolder("Gradient Colors");
        gradientFolder2.addColor(params2, "colorStop1").name("Stop 1");
        gradientFolder2.addColor(params2, "colorStop2").name("Stop 2");
        gradientFolder2.addColor(params2, "colorStop3").name("Stop 3");
        gradientFolder2.addColor(params2, "colorStop4").name("Stop 4");
        gradientFolder2.addColor(params2, "colorStop5").name("Stop 5");

        const stopPosFolder2 = layer2Folder.addFolder("Color Stop Positions");
        stopPosFolder2.add(params2, "stopPos1", 0, 1, 0.01).name("Stop 1 Position");
        stopPosFolder2.add(params2, "stopPos2", 0, 1, 0.01).name("Stop 2 Position");
        stopPosFolder2.add(params2, "stopPos3", 0, 1, 0.01).name("Stop 3 Position");
        stopPosFolder2.add(params2, "stopPos4", 0, 1, 0.01).name("Stop 4 Position");
        stopPosFolder2.add(params2, "stopPos5", 0, 1, 0.01).name("Stop 5 Position");

        const positionFolder2 = layer2Folder.addFolder("Position");
        positionFolder2.add(params2, "positionX", -1000, 1000, 1).name("Position X");
        positionFolder2.add(params2, "positionY", -1000, 1000, 1).name("Position Y");

        layer2Folder.add(params2, "scale", 0.5, 2.0, 0.01).name("Scale");
        layer2Folder.add(params2, "blur", 0, 200, 1).name("Blur");
        layer2Folder.add(params2, "feather", 0, 150, 1).name("Feather");
        layer2Folder.add(params2, "flowSpeed", 0, 1, 0.01).name("Flow Speed");
        layer2Folder.add(params2, "flowAmount", 0, 2, 0.01).name("Flow Amount");
        layer2Folder.add(params2, "noiseScale", 0.1, 3.0, 0.1).name("Noise Scale");
        layer2Folder.add(params2, "waveHeight", 0, 150, 1).name("Wave Height");

        // Blending mode between the two shapes - prominent placement
        const blendFolder = gui.addFolder("Layer Blending");
        blendFolder
          .add(params, "blendMode", blendModes)
          .name("Blend Mode")
          .onChange(() => {
            canvas2.style.mixBlendMode = params.blendMode;
          });

        // Global blur control
        gui
          .add(params, "globalBlur", 0, 50, 0.5)
          .name("Global Blur")
          .onChange(() => {
            updateGlobalBlur();
          });

        function updateGlobalBlur() {
          const blurValue = params.globalBlur > 0 ? `${params.globalBlur}px` : "none";
          canvas.style.filter = `blur(${blurValue})`;
          canvas2.style.filter = `blur(${blurValue})`;
        }

        // Grain overlay controls
        const grainFolder = gui.addFolder("Grain/Noise");
        grainFolder.add(params, "grainOpacity", 0, 1, 0.01).name("Grain Opacity").onChange(updateGrain);
        grainFolder.add(params, "grainScale", 0.1, 5.0, 0.1).name("Grain Scale").onChange(updateGrain);
        grainFolder.add(params, "grainBlend", blendModes).name("Grain Blend Mode").onChange(updateGrain);

        const grainOverlay = document.getElementById("grainOverlay");

        function updateGrain() {
          if (grainOverlay) {
            grainOverlay.style.opacity = params.grainOpacity;
            const baseSize = 200;
            const scaledSize = baseSize / params.grainScale;
            grainOverlay.style.backgroundSize = `${scaledSize}px ${scaledSize}px`;
            grainOverlay.style.mixBlendMode = params.grainBlend;
          }
        }

        // Initialize grain
        updateGrain();

        // Move preset folder to the top of the GUI
        setTimeout(() => {
          const guiUl = gui.domElement.querySelector("ul");
          const presetLi = presetFolder.domElement.parentElement;
          if (guiUl && presetLi && presetLi !== guiUl.firstElementChild) {
            guiUl.insertBefore(presetLi, guiUl.firstElementChild);
          }
        }, 100);

        // Load last used preset on page load
        const lastPresetName = localStorage.getItem(LAST_PRESET_KEY);
        if (lastPresetName) {
          const presets = savePresets();
          if (presets[lastPresetName]) {
            // Small delay to ensure GUI is ready
            setTimeout(() => {
              loadPreset(lastPresetName);
            }, 100);
          }
        }

        // Initialize preset list
        refreshPresetGUI();

        // Position GUI
        setTimeout(() => {
          gui.domElement.style.position = "fixed";
          gui.domElement.style.top = "20px";
          gui.domElement.style.left = "20px";
          gui.domElement.style.zIndex = "1000";
        }, 100);

        // Resize handler
        function resizeCanvas() {
          const displayWidth = canvas.clientWidth;
          const displayHeight = canvas.clientHeight;

          if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          }

          if (canvas2.width !== displayWidth || canvas2.height !== displayHeight) {
            canvas2.width = displayWidth;
            canvas2.height = displayHeight;
            gl2.viewport(0, 0, gl2.canvas.width, gl2.canvas.height);
          }
        }

        // Render loop
        let startTime = performance.now() / 1000.0;

        function render() {
          resizeCanvas();
          const currentTime = performance.now() / 1000.0 - startTime;

          // Render layer 1
          gl.useProgram(program);
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.enableVertexAttribArray(positionLocation);
          gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

          gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
          gl.uniform1f(timeLocation, currentTime);
          gl.uniform2f(centerLocation, gl.canvas.width / 2, gl.canvas.height / 2);
          gl.uniform1f(scaleLocation, params.scale);
          gl.uniform1f(blurLocation, params.blur);
          gl.uniform1f(featherLocation, params.feather);
          gl.uniform1f(flowSpeedLocation, params.flowSpeed);
          gl.uniform1f(flowAmountLocation, params.flowAmount);
          gl.uniform1f(noiseScaleLocation, params.noiseScale);
          gl.uniform1f(waveHeightLocation, params.waveHeight);
          gl.uniform2f(positionLocation_uniform, params.positionX, params.positionY);

          const rgb1 = hexToRgb(params.colorStop1);
          const rgb2 = hexToRgb(params.colorStop2);
          const rgb3 = hexToRgb(params.colorStop3);
          const rgb4 = hexToRgb(params.colorStop4);
          const rgb5 = hexToRgb(params.colorStop5);
          gl.uniform3f(colorStop1Location, rgb1[0], rgb1[1], rgb1[2]);
          gl.uniform3f(colorStop2Location, rgb2[0], rgb2[1], rgb2[2]);
          gl.uniform3f(colorStop3Location, rgb3[0], rgb3[1], rgb3[2]);
          gl.uniform3f(colorStop4Location, rgb4[0], rgb4[1], rgb4[2]);
          gl.uniform3f(colorStop5Location, rgb5[0], rgb5[1], rgb5[2]);
          gl.uniform1f(stopPos1Location, params.stopPos1);
          gl.uniform1f(stopPos2Location, params.stopPos2);
          gl.uniform1f(stopPos3Location, params.stopPos3);
          gl.uniform1f(stopPos4Location, params.stopPos4);
          gl.uniform1f(stopPos5Location, params.stopPos5);

          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.drawArrays(gl.TRIANGLES, 0, 6);

          // Render layer 2
          gl2.useProgram(program2);
          gl2.enable(gl2.BLEND);
          gl2.blendFunc(gl2.SRC_ALPHA, gl2.ONE_MINUS_SRC_ALPHA);

          gl2.bindBuffer(gl2.ARRAY_BUFFER, positionBuffer2);
          gl2.enableVertexAttribArray(positionLocation2);
          gl2.vertexAttribPointer(positionLocation2, 2, gl2.FLOAT, false, 0, 0);

          gl2.uniform2f(resolutionLocation2, gl2.canvas.width, gl2.canvas.height);
          gl2.uniform1f(timeLocation2, currentTime);
          gl2.uniform2f(centerLocation2, gl2.canvas.width / 2, gl2.canvas.height / 2);
          gl2.uniform1f(scaleLocation2, params2.scale);
          gl2.uniform1f(blurLocation2, params2.blur);
          gl2.uniform1f(featherLocation2, params2.feather);
          gl2.uniform1f(flowSpeedLocation2, params2.flowSpeed);
          gl2.uniform1f(flowAmountLocation2, params2.flowAmount);
          gl2.uniform1f(noiseScaleLocation2, params2.noiseScale);
          gl2.uniform1f(waveHeightLocation2, params2.waveHeight);
          gl2.uniform2f(positionLocation_uniform2, params2.positionX, params2.positionY);

          const rgb1_2 = hexToRgb(params2.colorStop1);
          const rgb2_2 = hexToRgb(params2.colorStop2);
          const rgb3_2 = hexToRgb(params2.colorStop3);
          const rgb4_2 = hexToRgb(params2.colorStop4);
          const rgb5_2 = hexToRgb(params2.colorStop5);
          gl2.uniform3f(colorStop1Location2, rgb1_2[0], rgb1_2[1], rgb1_2[2]);
          gl2.uniform3f(colorStop2Location2, rgb2_2[0], rgb2_2[1], rgb2_2[2]);
          gl2.uniform3f(colorStop3Location2, rgb3_2[0], rgb3_2[1], rgb3_2[2]);
          gl2.uniform3f(colorStop4Location2, rgb4_2[0], rgb4_2[1], rgb4_2[2]);
          gl2.uniform3f(colorStop5Location2, rgb5_2[0], rgb5_2[1], rgb5_2[2]);
          gl2.uniform1f(stopPos1Location2, params2.stopPos1);
          gl2.uniform1f(stopPos2Location2, params2.stopPos2);
          gl2.uniform1f(stopPos3Location2, params2.stopPos3);
          gl2.uniform1f(stopPos4Location2, params2.stopPos4);
          gl2.uniform1f(stopPos5Location2, params2.stopPos5);

          gl2.clearColor(0, 0, 0, 0);
          gl2.clear(gl2.COLOR_BUFFER_BIT);
          gl2.drawArrays(gl2.TRIANGLES, 0, 6);

          requestAnimationFrame(render);
        }

        // Set initial blend mode
        canvas2.style.mixBlendMode = params.blendMode;

        // Set initial global blur
        updateGlobalBlur();

        // Start rendering
        resizeCanvas();
        render();
      </script>
    </div>
  </body>
</html>
