<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>Glows Gradient</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0f0f0f;
      }
      .stage {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        overflow: hidden;
        background-image: url("../../assets/dummy-gray.jpg");
        background-size: cover;
        background-position: center top;
        background-repeat: no-repeat;
      }
      svg {
        width: min(90vw, 1200px);
        height: auto;
        display: block;
        overflow: visible;
      }

      use[href="#shapePath"] {
        transform-origin: center;
        transform-box: fill-box;
      }
    </style>
  </head>
  <body>
    <div class="stage">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 1885.76 1161.29">
        <defs>
          <path
            id="shapePath"
            d="M104,707.88c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,516.68,182.89,738.46,119.23,203.13-58.31,162.62-132.51,469.23-250,177.18-67.9,293.4-82.47,334.62-180.77,29.04-69.26,3.49-138.71-34.62-242.31-28.72-78.07-89.01-235.1-253.85-346.15C1534.34,70.06,1424.01-4.27,1273.23.19c-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-83.49,117.93-165.38,165.38-95.29,55.22-228.68,73.34-346.15,34.62-154.72-51-194.53-171.81-276.92-150-62.17,16.46-90.97,98.86-111.54,157.69-9.08,25.97-47.39,135.58,0,242.31,22.51,50.7,54.66,78.89,80.77,103.85Z" />

          <!-- Create gradient that follows shape using blur-based distance field -->
          <filter
            id="shapeGradient"
            filterUnits="userSpaceOnUse"
            x="-600"
            y="-600"
            width="3000"
            height="2400">
            <!-- Organic displacement using turbulence -->
            <feTurbulence
              id="displaceTurbulence"
              type="fractalNoise"
              baseFrequency="0.01 0.01"
              numOctaves="5"
              result="turbulence"
              seed="1" />
            <feDisplacementMap
              id="displaceMap"
              in="SourceGraphic"
              in2="turbulence"
              scale="0"
              xChannelSelector="R"
              yChannelSelector="G"
              result="displaced" />

            <!-- Extract alpha from displaced shape -->
            <feColorMatrix
              in="displaced"
              type="matrix"
              values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0"
              result="displacedAlpha" />

            <!-- Blur SourceAlpha to create distance field: center is bright (1), edges fade to dark (0) -->
            <feGaussianBlur
              in="displacedAlpha"
              stdDeviation="200"
              result="blurred"
              id="dfBlur" />
            <!-- Invert so center = 0 (maps to red) and edge = 1 (maps to magenta) -->
            <feComponentTransfer
              in="blurred"
              result="inverted">
              <feFuncA
                type="table"
                tableValues="1 0" />
            </feComponentTransfer>
            <!-- Copy alpha channel to RGB so we can map colors based on intensity -->
            <feColorMatrix
              in="inverted"
              type="matrix"
              values="0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 0"
              result="grayRGB" />

            <!-- Rainbow mapping from center → edges using table-based RGB lookups -->
            <!-- Order (center to edge): red → orange → yellow → green → cyan → blue → magenta
                 The alpha fades outward so it dissolves into the background. -->
            <feComponentTransfer
              in="grayRGB"
              result="gradient">
              <!-- R:  red(1) → orange(1) → yellow(1) → green(0) → cyan(0) → blue(0) → magenta(1) -->
              <feFuncR
                type="table"
                tableValues="1 1 1 0 0 0 1"
                id="funcR" />
              <!-- G:  red(0) → orange(0.5) → yellow(1) → green(1) → cyan(1) → blue(0) → magenta(0) -->
              <feFuncG
                type="table"
                tableValues="0 0.5 1 1 1 0 0"
                id="funcG" />
              <!-- B:  red(0) → orange(0) → yellow(0) → green(0) → cyan(1) → blue(1) → magenta(1) -->
              <feFuncB
                type="table"
                tableValues="0 0 0 0 1 1 1"
                id="funcB" />
              <!-- Alpha: keep bright in center, fade gradually to edge -->
              <feFuncA
                type="table"
                tableValues="1.0 1.0 0.95 0.85 0.7 0.4 0.0"
                id="funcA" />
            </feComponentTransfer>

            <!-- Extra feather: blur the displaced alpha and use as a soft edge mask -->
            <feGaussianBlur
              id="featherBlur"
              in="displacedAlpha"
              stdDeviation="40"
              result="featherMask" />
            <feComposite
              in="gradient"
              in2="featherMask"
              operator="in"
              result="feathered" />

            <!-- Brightness and Contrast adjustments -->
            <feComponentTransfer
              in="feathered"
              result="final">
              <feFuncR
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessR" />
              <feFuncG
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessG" />
              <feFuncB
                type="linear"
                slope="1"
                intercept="0"
                id="brightnessB" />
            </feComponentTransfer>
          </filter>
        </defs>

        <!-- Apply gradient filter -->
        <use
          id="shapeUse"
          href="#shapePath"
          fill="white"
          filter="url(#shapeGradient)" />
      </svg>
      <!-- lil-gui -->
      <script type="module">
        import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.21/+esm";
        const gui = new GUI();
        const params = {
          // Five color stops from center→edge
          stop1: "#FFD700", // Bright golden yellow
          stop2: "#FF7F00", // Rich orange
          stop3: "#E91E63", // Warm magenta
          stop4: "#9C27B0", // Purple
          stop5: "#483D8B", // Deep indigo
          // Color stop positions (0-1, center to edge)
          stopPos1: 0.0,
          stopPos2: 0.2,
          stopPos3: 0.5,
          stopPos4: 0.8,
          stopPos5: 1.0,
          blur: 200,
          centerOpacity: 1.0,
          edgeOpacity: 0.0,
          // Transform controls
          positionX: 0,
          positionY: 0,
          scale: 1.0,
          rotation: 0,
          skewX: 0,
          skewY: 0,
          // Feather control
          feather: 40,
          // Visual effects
          brightness: 1.0,
          contrast: 1.0,
          // Displacement controls
          displacementStrength: 0,
          displacementFrequency: 0.01,
          displacementOctaves: 5,
          displacementAnimated: false,
          displacementSpeed: 0.005,
          // Path data (stored as initial value)
          pathData:
            "M104,707.88c137.11,131.06,156.81,219.85,226.92,296.15,166.42,181.12,516.68,182.89,738.46,119.23,203.13-58.31,162.62-132.51,469.23-250,177.18-67.9,293.4-82.47,334.62-180.77,29.04-69.26,3.49-138.71-34.62-242.31-28.72-78.07-89.01-235.1-253.85-346.15C1534.34,70.06,1424.01-4.27,1273.23.19c-172.58,5.11-298.28,110.49-350,153.85-99.87,83.73-83.49,117.93-165.38,165.38-95.29,55.22-228.68,73.34-346.15,34.62-154.72-51-194.53-171.81-276.92-150-62.17,16.46-90.97,98.86-111.54,157.69-9.08,25.97-47.39,135.58,0,242.31,22.51,50.7,54.66,78.89,80.77,103.85Z",
        };

        const toRGB01 = (hex) => {
          const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex);
          if (!m) return [1, 1, 1];
          return [parseInt(m[1], 16) / 255, parseInt(m[2], 16) / 255, parseInt(m[3], 16) / 255];
        };

        function interpolateColorStops(colors, positions) {
          // Create an array of 256 entries (0-255) representing the gradient
          const result = new Array(256);
          const numStops = colors.length;

          for (let i = 0; i < 256; i++) {
            const t = i / 255; // Normalize to 0-1

            // Find which two stops to interpolate between
            let stopIndex = 0;
            for (let j = 0; j < numStops - 1; j++) {
              if (t >= positions[j] && t <= positions[j + 1]) {
                stopIndex = j;
                break;
              }
            }

            // Clamp to last stop if beyond
            if (t > positions[numStops - 1]) {
              stopIndex = numStops - 2;
            }

            const pos1 = positions[stopIndex];
            const pos2 = positions[stopIndex + 1];
            const color1 = colors[stopIndex];
            const color2 = colors[stopIndex + 1];

            // Interpolate between the two stops
            const range = pos2 - pos1;
            const localT = range > 0 ? (t - pos1) / range : 0;

            result[i] = [
              color1[0] + (color2[0] - color1[0]) * localT,
              color1[1] + (color2[1] - color1[1]) * localT,
              color1[2] + (color2[2] - color1[2]) * localT,
            ];
          }

          // Sample 7 points evenly to create table values
          const samplePoints = [0, 42, 85, 128, 170, 213, 255];
          return samplePoints.map((idx) => result[idx]);
        }

        function updateTables() {
          const colors = [params.stop1, params.stop2, params.stop3, params.stop4, params.stop5].map(toRGB01);
          const positions = [params.stopPos1, params.stopPos2, params.stopPos3, params.stopPos4, params.stopPos5]
            .map((p) => Math.max(0, Math.min(1, p)))
            .sort((a, b) => a - b);

          // Ensure positions are sorted and clamp colors accordingly
          const sortedPairs = positions.map((p, i) => ({ pos: p, color: colors[i] })).sort((a, b) => a.pos - b.pos);
          const sortedColors = sortedPairs.map((p) => p.color);
          const sortedPositions = sortedPairs.map((p) => p.pos);

          // Interpolate to create smooth gradient
          const interpolated = interpolateColorStops(sortedColors, sortedPositions);

          const r = interpolated.map((c) => c[0].toFixed(3)).join(" ");
          const g = interpolated.map((c) => c[1].toFixed(3)).join(" ");
          const b = interpolated.map((c) => c[2].toFixed(3)).join(" ");

          document.getElementById("funcR")?.setAttribute("tableValues", r);
          document.getElementById("funcG")?.setAttribute("tableValues", g);
          document.getElementById("funcB")?.setAttribute("tableValues", b);

          // Interpolate alpha based on stop positions
          const alphaStops = [params.centerOpacity, 0.95, 0.8, 0.55, params.edgeOpacity];
          const alphaInterpolated = interpolateColorStops(
            alphaStops.map((a) => [a, a, a]),
            sortedPositions
          );
          const a = alphaInterpolated.map((c) => Math.max(0, Math.min(1, c[0])).toFixed(2)).join(" ");
          document.getElementById("funcA")?.setAttribute("tableValues", a);
        }

        function updateBlur() {
          document.getElementById("dfBlur")?.setAttribute("stdDeviation", String(params.blur));
        }

        function updateTransform() {
          const useEl = document.getElementById("shapeUse");
          if (!useEl) return;
          const tx = params.positionX;
          const ty = params.positionY;
          const s = params.scale;
          const r = params.rotation;
          const skx = params.skewX;
          const sky = params.skewY;
          // Build transform string: translate → skew → rotate → scale
          useEl.setAttribute("transform", `translate(${tx}, ${ty}) skewX(${skx}) skewY(${sky}) rotate(${r}) scale(${s})`);
        }

        function updateFeather() {
          document.getElementById("featherBlur")?.setAttribute("stdDeviation", String(params.feather));
        }

        function updateEffects() {
          // Brightness: linear slope = brightness value
          // Contrast: use slope = contrast, intercept = -0.5 * contrast + 0.5
          const brightness = params.brightness;
          const contrast = params.contrast;
          const slope = brightness * contrast;
          const intercept = brightness * (-0.5 * contrast + 0.5);

          document.getElementById("brightnessR")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessR")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessG")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessG")?.setAttribute("intercept", String(intercept));
          document.getElementById("brightnessB")?.setAttribute("slope", String(slope));
          document.getElementById("brightnessB")?.setAttribute("intercept", String(intercept));
        }

        let displacementAnimationId = null;

        let displacementTime = 0;

        function updateDisplacement() {
          document.getElementById("displaceMap")?.setAttribute("scale", String(params.displacementStrength));

          const freq = params.displacementFrequency;
          document.getElementById("displaceTurbulence")?.setAttribute("baseFrequency", `${freq} ${freq}`);
          document.getElementById("displaceTurbulence")?.setAttribute("numOctaves", String(params.displacementOctaves));

          // Stop existing animation
          if (displacementAnimationId) {
            cancelAnimationFrame(displacementAnimationId);
            displacementAnimationId = null;
          }

          // Start animated displacement if enabled - lava lamp style
          if (params.displacementAnimated && params.displacementStrength > 0) {
            function animate() {
              displacementTime += params.displacementSpeed || 0.005;
              const baseFreq = params.displacementFrequency;
              const turbEl = document.getElementById("displaceTurbulence");
              if (turbEl) {
                // Lava lamp style: slow, smooth, flowing movement
                // Multiple sine waves at different frequencies for organic flow
                const wave1 = Math.sin(displacementTime * 0.3) * 0.003;
                const wave2 = Math.cos(displacementTime * 0.5) * 0.005;
                const wave3 = Math.sin(displacementTime * 0.7 + 1.5) * 0.002;

                const x = baseFreq + wave1 + wave2;
                const y = baseFreq + wave3 + Math.cos(displacementTime * 0.4) * 0.004;
                turbEl.setAttribute("baseFrequency", `${x} ${y}`);
              }
              displacementAnimationId = requestAnimationFrame(animate);
            }
            animate();
          } else {
            // Reset when not animated
            displacementTime = 0;
          }
        }

        function updatePath() {
          const pathEl = document.getElementById("shapePath");
          if (pathEl && params.pathData.trim()) {
            try {
              pathEl.setAttribute("d", params.pathData);
            } catch (e) {
              console.error("Invalid path data:", e);
              alert("Invalid SVG path data. Please check the syntax.");
            }
          }
        }

        const cf = gui.addFolder("Colors (center → edge)");
        cf.addColor(params, "stop1").name("Stop 1").onChange(updateTables);
        cf.addColor(params, "stop2").name("Stop 2").onChange(updateTables);
        cf.addColor(params, "stop3").name("Stop 3").onChange(updateTables);
        cf.addColor(params, "stop4").name("Stop 4").onChange(updateTables);
        cf.addColor(params, "stop5").name("Stop 5").onChange(updateTables);
        const sp = gui.addFolder("Stop Positions");
        sp.add(params, "stopPos1", 0, 1, 0.01).name("Stop 1 Position").onChange(updateTables);
        sp.add(params, "stopPos2", 0, 1, 0.01).name("Stop 2 Position").onChange(updateTables);
        sp.add(params, "stopPos3", 0, 1, 0.01).name("Stop 3 Position").onChange(updateTables);
        sp.add(params, "stopPos4", 0, 1, 0.01).name("Stop 4 Position").onChange(updateTables);
        sp.add(params, "stopPos5", 0, 1, 0.01).name("Stop 5 Position").onChange(updateTables);
        const af = gui.addFolder("Alpha");
        af.add(params, "centerOpacity", 0, 1, 0.01).name("Center Opacity").onChange(updateTables);
        af.add(params, "edgeOpacity", 0, 1, 0.01).name("Edge Opacity").onChange(updateTables);
        gui.add(params, "blur", 50, 400, 1).name("Blur (spread)").onChange(updateBlur);

        const tf = gui.addFolder("Transform");
        tf.add(params, "positionX", -2000, 2000, 1).name("Position X").onChange(updateTransform);
        tf.add(params, "positionY", -2000, 2000, 1).name("Position Y").onChange(updateTransform);
        tf.add(params, "scale", 0.1, 3, 0.01).name("Scale").onChange(updateTransform);
        tf.add(params, "rotation", -180, 180, 1).name("Rotation (deg)").onChange(updateTransform);
        tf.add(params, "skewX", -45, 45, 0.5).name("Skew X (deg)").onChange(updateTransform);
        tf.add(params, "skewY", -45, 45, 0.5).name("Skew Y (deg)").onChange(updateTransform);

        const ff = gui.addFolder("Edge Feather");
        ff.add(params, "feather", 0, 150, 1).name("Feather Amount").onChange(updateFeather);

        const vf = gui.addFolder("Visual Effects");
        vf.add(params, "brightness", 0, 3, 0.01).name("Brightness").onChange(updateEffects);
        vf.add(params, "contrast", 0, 3, 0.01).name("Contrast").onChange(updateEffects);

        const df = gui.addFolder("Displacement");
        df.add(params, "displacementStrength", 0, 1000, 5).name("Strength").onChange(updateDisplacement);
        df.add(params, "displacementFrequency", 0.005, 0.05, 0.001).name("Frequency (lower = smoother)").onChange(updateDisplacement);
        df.add(params, "displacementOctaves", 1, 8, 1).name("Octaves").onChange(updateDisplacement);
        df.add(params, "displacementAnimated").name("Lava Lamp (animated)").onChange(updateDisplacement);
        df.add(params, "displacementSpeed", 0.001, 0.02, 0.001).name("Animation Speed").onChange(updateDisplacement);

        const pathf = gui.addFolder("Shape Path");
        const pathController = pathf.add(params, "pathData").name("Path Data (SVG d attribute)");
        pathController.onChange(updatePath);
        pathf.add({ update: () => updatePath() }, "update").name("Update Shape");

        // Store initial path on load
        params.pathData = document.getElementById("shapePath")?.getAttribute("d") || params.pathData;

        // Position GUI on the left
        setTimeout(() => {
          gui.domElement.style.position = "fixed";
          gui.domElement.style.top = "20px";
          gui.domElement.style.left = "20px";
          gui.domElement.style.zIndex = "1000";
        }, 100);

        updateTables();
        updateBlur();
        updateTransform();
        updateFeather();
        updateEffects();
        updateDisplacement();
      </script>
    </div>
  </body>
</html>
